<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Super Helpers: The Bee Savers | Interactive Storybook</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }

    #videoPreload,
    #videoPreload2 {
      position: absolute;
      top: -9999px;
      left: -9999px;
      width: 10px;
      height: 10px;
    }

    /* Skip button style */
    #skipButton {
      position: absolute;
      bottom: 30px;
      right: 30px;
      padding: 12px 25px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      border: 2px solid rgba(255, 255, 255, 0.8);
      border-radius: 25px;
      font-family: "Microsoft YaHei", "SimHei", Arial, sans-serif;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      z-index: 1000;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }

    #skipButton:hover {
      background-color: rgba(255, 255, 255, 0.9);
      color: #333;
      transform: scale(1.05);
    }
  </style>
</head>

<body>
  <!-- Skip button -->
  <button id="skipButton">Skip Story</button>

  <!-- 添加背景音乐元素 -->
  <audio id="bgMusic" loop preload="auto">
    <source src="storytelling/bg-music.mp3" type="audio/mpeg">
  </audio>

  <!-- Preload two videos but hide them -->
  <video id="videoPreload" preload="auto" muted playsinline>
    <source src="storytelling/BG-Image.mp4" type="video/mp4">
  </video>
  <video id="videoPreload2" preload="auto" muted playsinline>
    <source src="storytelling/BG-Image-2.mp4" type="video/mp4">
  </video>

  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.11.5/dist/gsap.min.js"></script>
  <script>
    let scene, camera, renderer;
    let coverMesh, pageMesh, page2Mesh, page3Mesh, page4Mesh, page5Mesh, page6Mesh;
    let coverVideoElement = null; // Cover video element
    let coverVideoTexture = null; // Cover video texture
    let page1VideoElement = null; // Page1 video element
    let page1VideoTexture = null; // Page1 video texture 
    let page2VideoElement = null; // Page2 video element
    let page2VideoTexture = null; // Page2 video texture
    let page3VideoElement = null; // Page3 video element
    let page3VideoTexture = null; // Page3 video texture
    let page4VideoElement = null; // Page4 video element
    let page4VideoTexture = null; // Page4 video texture
    let page5VideoElement = null; // Page5 video element
    let page5VideoTexture = null; // Page5 video texture
    let page6VideoElement = null; // Page6 video element
    let page6VideoTexture = null; // Page6 video texture
    let clock = new THREE.Clock();
    let camTargetZ = 12;
    let storyShown = false;
    let isAnimating = false;
    let bookContainer;
    let currentPage = 1;
    let focusedPage = null;
    let originalPositions = {};
    let originalScales = {};
    let bgMusicElement = null; // 背景音乐元素

    // Variables for alternating video playback
    let videoElement1, videoElement2;
    let activeVideoElement;
    let videoTexture1, videoTexture2;
    let activeVideoTexture;
    let videoBackground;
    let isVideo1Active = true;

    // Global variable for debugging
    let debugVideoTexture = null;

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);

      // Maintain moderate brightness settings to avoid color distortion
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.gammaFactor = 2.2;
      renderer.toneMappingExposure = 1.2;

      document.body.appendChild(renderer.domElement);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 2, 14); // Adjust camera distance to ensure enlarged book is fully visible

      // Maintain moderate lighting intensity to avoid over-saturated colors
      scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.5));
      const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
      dirLight.position.set(5, 10, 7.5);
      scene.add(dirLight);

      // Add moderate ambient light
      const ambientLight = new THREE.AmbientLight(0x606060, 0.8);
      scene.add(ambientLight);

      // Create book container, position in scene center
      bookContainer = new THREE.Group();
      bookContainer.position.set(0, 2, 0);
      scene.add(bookContainer);

      // Add video background support
      setupDualVideoBackground();

      // Only preload necessary videos
      preloadCoverVideo();
      preloadPage1Video();
      preloadPage2Video();
      preloadPage3Video();
      preloadPage4Video();
      preloadPage5Video();
      preloadPage6Video();

      // Set initial state: show cover
      currentPage = 0;

      // Set total number of pages to prevent accidental jumps to non-existent pages
      const totalPages = 7; // 0:Cover, 1:Page one, 2:Page two, 3:Page three, 4:Page four, 5:Page five, 6:Page six

      // Set camera observation position
      camTargetZ = 12;
      camera.position.z = 12;

      // Initial attempt to play videos
      setTimeout(function () {
        if (videoElement1) videoElement1.play().catch(e => console.error('Delayed start of video1 failed:', e));
        if (videoElement2) videoElement2.play().catch(e => console.error('Delayed start of video2 failed:', e));
        if (coverVideoElement) coverVideoElement.play().catch(e => console.error('Delayed start of cover video failed:', e));
      }, 1000);

      // Register window click event - handle user interaction
      window.addEventListener('click', (event) => {
        // Try to start all videos on user interaction (resolves autoplay restrictions in some browsers)
        startAllVideos();

        // If animation is in progress, ignore clicks
        if (isAnimating) {
          console.log("Animation in progress, ignoring click");
          return;
        }

        // Calculate mouse position and convert to normalized coordinates
        const mouse = new THREE.Vector2();
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;  // Range: -1 to 1
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; // Range: -1 to 1

        // Update the raycaster for detecting 3D object clicks
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, camera);

        // Collect all objects that might be clicked - only check visible pages
        const clickableObjects = [];
        if (coverMesh && coverMesh.visible) clickableObjects.push(coverMesh);
        if (pageMesh && pageMesh.visible) clickableObjects.push(pageMesh);
        if (page2Mesh && page2Mesh.visible) clickableObjects.push(page2Mesh);
        if (page3Mesh && page3Mesh.visible) clickableObjects.push(page3Mesh);
        if (page4Mesh && page4Mesh.visible) clickableObjects.push(page4Mesh);
        if (page5Mesh && page5Mesh.visible) clickableObjects.push(page5Mesh);
        if (page6Mesh && page6Mesh.visible) clickableObjects.push(page6Mesh);

        // Check if the ray intersects with any clickable objects
        const intersects = raycaster.intersectObjects(clickableObjects);

        // If an interactive object was clicked
        if (intersects.length > 0) {
          const clickedObject = intersects[0].object;

          console.log("Clicked object:", clickedObject.userData.type, "Current page:", currentPage);

          // Determine if the clicked object is the current centrally displayed page
          const isCurrentCenterObject = (
            (clickedObject === coverMesh && currentPage === 0) ||
            (clickedObject === pageMesh && currentPage === 1) ||
            (clickedObject === page2Mesh && currentPage === 2) ||
            (clickedObject === page3Mesh && currentPage === 3) ||
            (clickedObject === page4Mesh && currentPage === 4) ||
            (clickedObject === page5Mesh && currentPage === 5) ||
            (clickedObject === page6Mesh && currentPage === 6)
          );

          // If it's the current central page and no page is enlarged
          if (isCurrentCenterObject && !focusedPage) {
            // If current page is clicked, turn to next page
            if (clickedObject === coverMesh) {
              console.log("Clicked cover, turning to first page");
              slideCoverAnimation();
              return;
            } else if (clickedObject === pageMesh) {
              console.log("Clicked first page, turning to second page");
              turnToPage2Animation();
              return;
            } else if (clickedObject === page2Mesh) {
              console.log("Clicked second page, turning to third page");
              turnToPage3Animation();
              return;
            } else if (clickedObject === page3Mesh) {
              console.log("Clicked third page, turning to fourth page");
              turnToPage4Animation();
              return;
            } else if (clickedObject === page4Mesh) {
              console.log("Clicked fourth page, turning to fifth page");
              turnToPage5Animation();
              return;
            } else if (clickedObject === page5Mesh) {
              console.log("Clicked fifth page, turning to sixth page");
              turnToPage6Animation();
              return;
            } else if (clickedObject === page6Mesh) {
              console.log("Clicked sixth page, this is the last page");
              transitionToGamePage();
              return;
            }
          }
          // If an enlarged page is clicked, restore original size
          else if (clickedObject === focusedPage) {
            console.log("Clicked enlarged page, restoring original size");
            resetAllPages();
            return;
          }
          // If a minimized page or side page is clicked
          else {
            console.log("Clicked non-central page:", clickedObject.userData.type);

            // Jump directly to the corresponding page based on clicked object
            if (clickedObject === coverMesh) {
              console.log("Clicked cover, jumping directly to cover");
              directResetToPage(0, coverMesh);
              return;
            } else if (clickedObject === pageMesh) {
              console.log("Clicked first page, jumping directly to first page");
              directResetToPage(1, pageMesh);
              return;
            } else if (clickedObject === page2Mesh) {
              console.log("Clicked second page, jumping directly to second page");
              directResetToPage(2, page2Mesh);
              return;
            } else if (clickedObject === page3Mesh) {
              console.log("Clicked third page, jumping directly to third page");
              directResetToPage(3, page3Mesh);
              return;
            } else if (clickedObject === page4Mesh) {
              console.log("Clicked fourth page, jumping directly to fourth page");
              directResetToPage(4, page4Mesh);
              return;
            } else if (clickedObject === page5Mesh) {
              console.log("Clicked fifth page, jumping directly to fifth page");
              directResetToPage(5, page5Mesh);
              return;
            } else if (clickedObject === page6Mesh) {
              console.log("Clicked sixth page, jumping directly to sixth page");
              directResetToPage(6, page6Mesh);
              return;
            }
          }
        }
        // Clicked empty area
        else if (focusedPage) {
          console.log("Clicked empty area, restoring all pages");
          resetAllPages();
        }
      });

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);

        // Also update background size if it's created
        if (videoBackground) {
          updateBackgroundSize(videoBackground);
        }
      });

      // Add Skip button click event
      document.getElementById('skipButton').addEventListener('click', function () {
        console.log("Clicked Skip button, redirecting to game page");
        window.location.href = 'game.html';
      });

      // 初始化并播放背景音乐
      bgMusicElement = document.getElementById('bgMusic');
      if (bgMusicElement) {
        bgMusicElement.volume = 0.6; // 将初始音量从0.8降低到0.6
        bgMusicElement.play().catch(e => console.error('无法播放背景音乐:', e));
      }
    }

    // Add Skip functionality - return to cover without animation
    function skipToMainCover() {
      // If animation is in progress, ignore click
      if (isAnimating) {
        console.log("Animation in progress, ignoring Skip request");
        return;
      }

      console.log("Executing Skip action, returning directly to cover");
      isAnimating = true;

      // Clear focus state
      focusedPage = null;

      // Stop all videos
      stopAllVideos();

      // Set state directly, without animation
      if (coverMesh) {
        // Ensure cover is visible
        coverMesh.visible = true;

        // Set cover position and size directly
        coverMesh.position.set(0, 0, 2);
        coverMesh.scale.set(1.3, 1.3, 1.3);
        coverMesh.rotation.set(0, 0, 0);

        // Ensure cover is on top
        bookContainer.remove(coverMesh);
        bookContainer.add(coverMesh);
      }

      // Hide all non-cover pages
      if (pageMesh) pageMesh.visible = false;
      if (page2Mesh) page2Mesh.visible = false;
      if (page3Mesh) page3Mesh.visible = false;
      if (page4Mesh) page4Mesh.visible = false;
      if (page5Mesh) page5Mesh.visible = false;
      if (page6Mesh) page6Mesh.visible = false;

      // Set current page to cover
      currentPage = 0;

      // Play cover video
      if (coverVideoElement) {
        coverVideoElement.currentTime = 0;
        coverVideoElement.play().catch(e => console.error('Unable to play cover video:', e));
      }

      // Reset camera position
      camera.position.set(0, 2, 12);

      // Complete operation
      isAnimating = false;
      console.log("Directly returned to cover state");
    }

    // Helper function to start all videos
    function startAllVideos() {
      if (videoElement1 && videoElement1.paused) {
        videoElement1.play().catch(e => console.error('Unable to play background video1:', e));
      }
      if (videoElement2 && videoElement2.paused) {
        videoElement2.play().catch(e => console.error('Unable to play background video2:', e));
      }

      // 只有在當前頁面是封面時才播放封面視頻和音頻
      if (coverVideoElement && coverVideoElement.paused) {
        // 臨時移除播放事件監聽器，確保只有在當前頁面是封面時才播放音頻
        const oldPlayHandler = coverVideoElement._playHandler;
        if (oldPlayHandler) {
          coverVideoElement.removeEventListener('play', oldPlayHandler);
        }
        
        if (currentPage === 0) {
          // 如果當前頁面是封面，添加監聽器來播放音頻
          const playHandler = function() {
            const coverAudio = document.getElementById('coverAudio');
            if (coverAudio) {
              coverAudio.currentTime = 0;
              coverAudio.play().catch(e => console.error('無法播放cover音頻:', e));
              
              // 降低背景音乐音量
              if (bgMusicElement) {
                bgMusicElement.volume = 0.05; // 从0.1降低到0.05
              }
            }
          };
          coverVideoElement._playHandler = playHandler;
          coverVideoElement.addEventListener('play', playHandler);
        }
        
        coverVideoElement.play().catch(e => console.error('Unable to play cover video:', e));
      }

      // 只有在當前頁面是第一頁時才播放page1視頻和音頻
      if (page1VideoElement && page1VideoElement.paused) {
        // 臨時移除播放事件監聽器
        const oldPlayHandler = page1VideoElement._playHandler;
        if (oldPlayHandler) {
          page1VideoElement.removeEventListener('play', oldPlayHandler);
        }
        
        if (currentPage === 1) {
          // 如果當前頁面是第一頁，添加監聽器來播放音頻
          const playHandler = function() {
            const page1Audio = document.getElementById('page1Audio');
            if (page1Audio) {
              page1Audio.currentTime = 0;
              page1Audio.play().catch(e => console.error('無法播放page1音頻:', e));
              
              // 降低背景音乐音量
              if (bgMusicElement) {
                bgMusicElement.volume = 0.05; // 从0.1降低到0.05
              }
            }
          };
          page1VideoElement._playHandler = playHandler;
          page1VideoElement.addEventListener('play', playHandler);
        }
        
        page1VideoElement.play().catch(e => console.error('Unable to play page1 video:', e));
      }

      // 只有在當前頁面是第二頁時才播放page2視頻和音頻
      if (page2VideoElement && page2VideoElement.paused) {
        // 臨時移除播放事件監聽器
        const oldPlayHandler = page2VideoElement._playHandler;
        if (oldPlayHandler) {
          page2VideoElement.removeEventListener('play', oldPlayHandler);
        }
        
        if (currentPage === 2) {
          // 如果當前頁面是第二頁，添加監聽器來播放音頻
          const playHandler = function() {
            const page2Audio = document.getElementById('page2Audio');
            if (page2Audio) {
              page2Audio.currentTime = 0;
              page2Audio.play().catch(e => console.error('無法播放page2音頻:', e));
              
              // 降低背景音乐音量
              if (bgMusicElement) {
                bgMusicElement.volume = 0.05; // 从0.1降低到0.05
              }
            }
          };
          page2VideoElement._playHandler = playHandler;
          page2VideoElement.addEventListener('play', playHandler);
        }
        
        page2VideoElement.play().catch(e => console.error('Unable to play page2 video:', e));
      }
      
      // 只有在當前頁面是第三頁時才播放page3視頻和音頻
      if (page3VideoElement && page3VideoElement.paused) {
        // 臨時移除播放事件監聽器
        const oldPlayHandler = page3VideoElement._playHandler;
        if (oldPlayHandler) {
          page3VideoElement.removeEventListener('play', oldPlayHandler);
        }
        
        if (currentPage === 3) {
          // 如果當前頁面是第三頁，添加監聽器來播放音頻
          const playHandler = function() {
            const page3Audio = document.getElementById('page3Audio');
            if (page3Audio) {
              page3Audio.currentTime = 0;
              page3Audio.play().catch(e => console.error('無法播放page3音頻:', e));
              
              // 降低背景音乐音量
              if (bgMusicElement) {
                bgMusicElement.volume = 0.05; // 从0.1降低到0.05
              }
            }
          };
          page3VideoElement._playHandler = playHandler;
          page3VideoElement.addEventListener('play', playHandler);
        }
        
        page3VideoElement.play().catch(e => console.error('Unable to play page3 video:', e));
      }
      
      // 只有在當前頁面是第四頁時才播放page4視頻和音頻
      if (page4VideoElement && page4VideoElement.paused) {
        // 臨時移除播放事件監聽器
        const oldPlayHandler = page4VideoElement._playHandler;
        if (oldPlayHandler) {
          page4VideoElement.removeEventListener('play', oldPlayHandler);
        }
        
        if (currentPage === 4) {
          // 如果當前頁面是第四頁，添加監聽器來播放音頻
          const playHandler = function() {
            const page4Audio = document.getElementById('page4Audio');
            if (page4Audio) {
              page4Audio.currentTime = 0;
              page4Audio.play().catch(e => console.error('無法播放page4音頻:', e));
              
              // 降低背景音乐音量
              if (bgMusicElement) {
                bgMusicElement.volume = 0.05; // 从0.1降低到0.05
              }
            }
          };
          page4VideoElement._playHandler = playHandler;
          page4VideoElement.addEventListener('play', playHandler);
        }
        
        page4VideoElement.play().catch(e => console.error('Unable to play page4 video:', e));
      }
      
      // 只有在當前頁面是第五頁時才播放page5視頻和音頻
      if (page5VideoElement && page5VideoElement.paused) {
        // 臨時移除播放事件監聽器
        const oldPlayHandler = page5VideoElement._playHandler;
        if (oldPlayHandler) {
          page5VideoElement.removeEventListener('play', oldPlayHandler);
        }
        
        if (currentPage === 5) {
          // 如果當前頁面是第五頁，添加監聽器來播放音頻
          const playHandler = function() {
            const page5Audio = document.getElementById('page5Audio');
            if (page5Audio) {
              page5Audio.currentTime = 0;
              page5Audio.play().catch(e => console.error('無法播放page5音頻:', e));
              
              // 降低背景音乐音量
              if (bgMusicElement) {
                bgMusicElement.volume = 0.05; // 从0.1降低到0.05
              }
            }
          };
          page5VideoElement._playHandler = playHandler;
          page5VideoElement.addEventListener('play', playHandler);
        }
        
        page5VideoElement.play().catch(e => console.error('Unable to play page5 video:', e));
      }
      
      // 只有在當前頁面是第六頁時才播放page6視頻和音頻
      if (page6VideoElement && page6VideoElement.paused) {
        // 臨時移除播放事件監聽器
        const oldPlayHandler = page6VideoElement._playHandler;
        if (oldPlayHandler) {
          page6VideoElement.removeEventListener('play', oldPlayHandler);
        }
        
        if (currentPage === 6) {
          // 如果當前頁面是第六頁，添加監聽器來播放音頻
          const playHandler = function() {
            const page6Audio = document.getElementById('page6Audio');
            if (page6Audio) {
              page6Audio.currentTime = 0;
              page6Audio.play().catch(e => console.error('無法播放page6音頻:', e));
              
              // 降低背景音乐音量
              if (bgMusicElement) {
                bgMusicElement.volume = 0.05; // 从0.1降低到0.05
              }
            }
          };
          page6VideoElement._playHandler = playHandler;
          page6VideoElement.addEventListener('play', playHandler);
        }
        
        page6VideoElement.play().catch(e => console.error('Unable to play page6 video:', e));
      }
    }

    // Set dual video background
    function setupDualVideoBackground() {
      // Get two video elements
      videoElement1 = document.getElementById('videoPreload');
      videoElement2 = document.getElementById('videoPreload2');

      if (!videoElement1 || !videoElement2) {
        console.error('Unable to find video elements');
        fallbackToImage();
        return;
      }

      console.log('Found two video elements, setting alternating playback');

      // Set properties of both videos
      videoElement1.muted = true;
      videoElement1.playsInline = true;
      videoElement1.loop = false; // We won't loop manually, so no need to loop

      videoElement2.muted = true;
      videoElement2.playsInline = true;
      videoElement2.loop = false;

      // Activate first video
      activeVideoElement = videoElement1;
      isVideo1Active = true;

      // Create two video textures
      videoTexture1 = new THREE.VideoTexture(videoElement1);
      setupVideoTexture(videoTexture1);

      videoTexture2 = new THREE.VideoTexture(videoElement2);
      setupVideoTexture(videoTexture2);

      // Activate first texture
      activeVideoTexture = videoTexture1;
      debugVideoTexture = videoTexture1;

      // Ensure that the other video starts playing automatically when the first one ends
      videoElement1.addEventListener('timeupdate', function () {
        // Prepare to switch when video1 is about to end (last 0.5 seconds)
        if (videoElement1.currentTime > videoElement1.duration - 0.5 && isVideo1Active) {
          videoElement2.currentTime = 0;
          videoElement2.play().catch(e => console.error('Failed to preload video2:', e));
        }
      });

      videoElement1.addEventListener('ended', function () {
        console.log('Video1 finished, switching to video2');
        // Start video2 immediately (already preloaded)
        videoElement2.play().catch(e => console.error('Failed to switch to video2:', e));

        // Update active video reference
        activeVideoElement = videoElement2;
        activeVideoTexture = videoTexture2;
        debugVideoTexture = videoTexture2;
        isVideo1Active = false;

        // Update background texture
        if (videoBackground && videoBackground.material) {
          videoBackground.material.map = videoTexture2;
        }
      });

      videoElement2.addEventListener('timeupdate', function () {
        // Prepare to switch when video2 is about to end (last 0.5 seconds)
        if (videoElement2.currentTime > videoElement2.duration - 0.5 && !isVideo1Active) {
          videoElement1.currentTime = 0;
          videoElement1.play().catch(e => console.error('Failed to preload video1:', e));
        }
      });

      videoElement2.addEventListener('ended', function () {
        console.log('Video2 finished, switching to video1');
        // Start video1 immediately (already preloaded)
        videoElement1.play().catch(e => console.error('Failed to switch to video1:', e));

        // Update active video reference
        activeVideoElement = videoElement1;
        activeVideoTexture = videoTexture1;
        debugVideoTexture = videoTexture1;
        isVideo1Active = true;

        // Update background texture
        if (videoBackground && videoBackground.material) {
          videoBackground.material.map = videoTexture1;
        }
      });

      // Start trying to play the first video
      videoElement1.play().then(() => {
        console.log('Video1 started playing');
        // Create background
        createBackgroundWithTexture(videoTexture1);
      }).catch(error => {
        console.error('Failed to play initial video:', error);
        fallbackToImage();
      });
    }

    // Set common properties for video textures
    function setupVideoTexture(texture) {
      texture.wrapS = THREE.ClampToEdgeWrapping;
      texture.wrapT = THREE.ClampToEdgeWrapping;
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.center.set(0.5, 0.5);
      texture.repeat.set(1, 1);
      texture.encoding = THREE.sRGBEncoding;
    }

    function fallbackToImage() {
      // Fallback to static image
      console.log('Using static image as background');
      const loader = new THREE.TextureLoader();
      loader.load('storytelling/forest_background.jpg', function (texture) {
        createBackgroundWithTexture(texture);
      });
    }

    // Update background size based on window size
    function updateBackgroundSize(background) {
      const aspectRatio = window.innerWidth / window.innerHeight;
      let newWidth, newHeight;

      if (aspectRatio > 16 / 9) {
        // Wide screen device, prioritize width
        newWidth = 60 * aspectRatio / (16 / 9); // Reduce from 80 to 60
        newHeight = 60 * (9 / 16);
      } else {
        // Tall screen device, prioritize height
        newWidth = 60; // Reduce from 80 to 60
        newHeight = 60 / aspectRatio * (16 / 9);
      }

      background.geometry = new THREE.PlaneGeometry(newWidth, newHeight);
      console.log(`Screen adjustment: ${aspectRatio.toFixed(2)}, New background size: ${newWidth.toFixed(2)}x${newHeight.toFixed(2)}`);
    }

    // Create background using given texture
    function createBackgroundWithTexture(texture) {
      console.log('Creating background, using texture:', texture);

      // Calculate background size to make it smaller
      const aspectRatio = window.innerWidth / window.innerHeight;
      let bgWidth, bgHeight;

      if (aspectRatio > 16 / 9) {
        // Wide screen device, prioritize width
        bgWidth = 60 * aspectRatio / (16 / 9); // Reduce from 80 to 60
        bgHeight = 60 * (9 / 16);
      } else {
        // Tall screen device, prioritize height
        bgWidth = 60; // Reduce from 80 to 60
        bgHeight = 60 / aspectRatio * (16 / 9);
      }

      console.log(`Screen aspect ratio: ${aspectRatio.toFixed(2)}, Background size: ${bgWidth.toFixed(2)}x${bgHeight.toFixed(2)}`);

      const bgGeometry = new THREE.PlaneGeometry(bgWidth, bgHeight);
      const bgMaterial = new THREE.MeshBasicMaterial({
        map: texture,
        side: THREE.DoubleSide,
      });

      // Main background panel - adjust position and size
      videoBackground = new THREE.Mesh(bgGeometry, bgMaterial);
      videoBackground.position.set(0, 0, -18); // Slightly closer, adjusted from -20 to -18
      bookContainer.add(videoBackground);

      // Add particle effect
      addParticles(bookContainer);

      // Reduce fog to make video clearer
      scene.fog = new THREE.FogExp2(0xaaccff, 0.0005);

      // Adjust camera position for better background observation
      camera.position.z = 12;
      camTargetZ = 10;
    }

    // Modify particle effect to not block video
    function addParticles(parent) {
      const particlesGeometry = new THREE.BufferGeometry();
      const particleCount = 300; // Reduce particle count

      const positionArray = new Float32Array(particleCount * 3);
      const sizeArray = new Float32Array(particleCount);

      for (let i = 0; i < particleCount; i++) {
        // Randomly distributed around the field of view, not concentrated in the center
        const radius = 12 + Math.random() * 18; // Increase range of particle distribution
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI / 2; // Hemisphere distribution

        // Distributed around the area, not blocking the center of the video
        positionArray[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
        positionArray[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
        positionArray[i * 3 + 2] = -radius * Math.cos(phi) - 2; // Bias towards the back

        sizeArray[i] = 0.05 + Math.random() * 0.15; // Increase particle size
      }

      particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positionArray, 3));
      particlesGeometry.setAttribute('size', new THREE.BufferAttribute(sizeArray, 1));

      const particlesMaterial = new THREE.PointsMaterial({
        color: 0xffffff, // Use pure white, enhance brightness
        size: 0.15, // Increase size
        transparent: true,
        opacity: 0.7, // Increase opacity, improve visibility
        sizeAttenuation: true
      });

      const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
      parent.add(particleSystem);

      // Add slow rotation animation
      gsap.to(particleSystem.rotation, {
        y: Math.PI * 2,
        duration: 180, // Slower rotation
        repeat: -1,
        ease: "none"
      });
    }

    // Preload page1 video
    function preloadPage1Video() {
      // Create hidden video element
      page1VideoElement = document.createElement('video');
      page1VideoElement.id = 'page1Video';
      page1VideoElement.style.display = 'none';
      page1VideoElement.muted = true;
      page1VideoElement.playsInline = true;
      page1VideoElement.loop = true; // Loop playback
      page1VideoElement.crossOrigin = 'anonymous';
      page1VideoElement.preload = 'auto';

      // 創建音頻元素用於播放page1.mp3
      const page1AudioElement = document.createElement('audio');
      page1AudioElement.id = 'page1Audio';
      page1AudioElement.src = 'storytelling/page1.mp3';
      page1AudioElement.preload = 'auto';
      document.body.appendChild(page1AudioElement);

      // Add video source
      const source = document.createElement('source');
      source.src = 'storytelling/page1.mp4';
      source.type = 'video/mp4';
      page1VideoElement.appendChild(source);

      // Add to DOM
      document.body.appendChild(page1VideoElement);

      // Load video
      page1VideoElement.load();

      // Add load success event
      page1VideoElement.addEventListener('canplaythrough', function onCanPlay() {
        console.log('Page1 video loaded, ready to play');

        // Create video texture (but don't play yet)
        if (!page1VideoTexture) {
          page1VideoTexture = new THREE.VideoTexture(page1VideoElement);
          page1VideoTexture.minFilter = THREE.LinearFilter;
          page1VideoTexture.magFilter = THREE.LinearFilter;
          page1VideoTexture.format = THREE.RGBAFormat;
          page1VideoTexture.encoding = THREE.sRGBEncoding;
          page1VideoTexture.generateMipmaps = false;
        }

        // Remove event listener to avoid duplicate calls
        page1VideoElement.removeEventListener('canplaythrough', onCanPlay);
      });

      // Add error handling
      page1VideoElement.addEventListener('error', function (e) {
        console.error('Failed to load Page1 video:', e);
        // Load static image as fallback
        const loader = new THREE.TextureLoader();
        loader.load('storytelling/page1.jpg', function (texture) {
          page1VideoTexture = texture;
        });
      });

      console.log('Page1 video preloading started');
    }

    // Preload page2 video
    function preloadPage2Video() {
      // Create hidden video element
      page2VideoElement = document.createElement('video');
      page2VideoElement.id = 'page2Video';
      page2VideoElement.style.display = 'none';
      page2VideoElement.muted = true;
      page2VideoElement.playsInline = true;
      page2VideoElement.loop = true; // Allow video to loop playback
      page2VideoElement.crossOrigin = 'anonymous';
      page2VideoElement.preload = 'auto'; // Ensure preloading

      // 創建音頻元素用於播放page2.mp3
      const page2AudioElement = document.createElement('audio');
      page2AudioElement.id = 'page2Audio';
      page2AudioElement.src = 'storytelling/page2.mp3';
      page2AudioElement.preload = 'auto';
      document.body.appendChild(page2AudioElement);

      // Add video source
      const source = document.createElement('source');
      source.src = 'storytelling/page2.mp4';
      source.type = 'video/mp4';
      page2VideoElement.appendChild(source);

      // Add to DOM
      document.body.appendChild(page2VideoElement);

      // Load video
      page2VideoElement.load();

      // When video has loaded enough data
      page2VideoElement.addEventListener('canplaythrough', function onCanPlay() {
        console.log('Page2 video ready to play');

        // Create video texture (but don't play yet)
        if (!page2VideoTexture) {
          page2VideoTexture = new THREE.VideoTexture(page2VideoElement);
          page2VideoTexture.minFilter = THREE.LinearFilter;
          page2VideoTexture.magFilter = THREE.LinearFilter;
          page2VideoTexture.format = THREE.RGBAFormat;
          page2VideoTexture.encoding = THREE.sRGBEncoding;
          page2VideoTexture.generateMipmaps = false;
        }

        // Remove event listener to avoid duplicate calls
        page2VideoElement.removeEventListener('canplaythrough', onCanPlay);
      });

      // Add error handling
      page2VideoElement.addEventListener('error', function (e) {
        console.error('Failed to load Page2 video:', e);
        // Load static image as fallback
        const loader = new THREE.TextureLoader();
        loader.load('storytelling/page2.jpg', function (texture) {
          page2VideoTexture = texture;
        });
      });

      console.log('Page2 video preloading started');
    }

    // Preload page3 video
    function preloadPage3Video() {
      // Create hidden video element
      page3VideoElement = document.createElement('video');
      page3VideoElement.id = 'page3Video';
      page3VideoElement.style.display = 'none';
      page3VideoElement.muted = true;
      page3VideoElement.playsInline = true;
      page3VideoElement.loop = true; // Allow video to loop playback
      page3VideoElement.crossOrigin = 'anonymous';
      page3VideoElement.preload = 'auto'; // Ensure preloading

      // 創建音頻元素用於播放page3.mp3
      const page3AudioElement = document.createElement('audio');
      page3AudioElement.id = 'page3Audio';
      page3AudioElement.src = 'storytelling/page3.mp3';
      page3AudioElement.preload = 'auto';
      document.body.appendChild(page3AudioElement);

      // Add video source
      const source = document.createElement('source');
      source.src = 'storytelling/page3.mp4';
      source.type = 'video/mp4';
      page3VideoElement.appendChild(source);

      // Add to DOM
      document.body.appendChild(page3VideoElement);

      // Load video
      page3VideoElement.load();

      // When video has loaded enough data
      page3VideoElement.addEventListener('canplaythrough', function onCanPlay() {
        console.log('Page3 video ready to play');

        // Create video texture (but don't play yet)
        if (!page3VideoTexture) {
          page3VideoTexture = new THREE.VideoTexture(page3VideoElement);
          page3VideoTexture.minFilter = THREE.LinearFilter;
          page3VideoTexture.magFilter = THREE.LinearFilter;
          page3VideoTexture.format = THREE.RGBAFormat;
          page3VideoTexture.encoding = THREE.sRGBEncoding;
          page3VideoTexture.generateMipmaps = false;
        }

        // Remove event listener to avoid duplicate calls
        page3VideoElement.removeEventListener('canplaythrough', onCanPlay);
      });

      // Add error handling
      page3VideoElement.addEventListener('error', function (e) {
        console.error('Failed to load Page3 video:', e);
        // Load static image as fallback
        const loader = new THREE.TextureLoader();
        loader.load('storytelling/page3.jpg', function (texture) {
          page3VideoTexture = texture;
        });
      });

      console.log('Page3 video preloading started');
    }

    // Preload page4 video
    function preloadPage4Video() {
      // Create hidden video element
      page4VideoElement = document.createElement('video');
      page4VideoElement.id = 'page4Video';
      page4VideoElement.style.display = 'none';
      page4VideoElement.muted = true;
      page4VideoElement.playsInline = true;
      page4VideoElement.loop = true; // Allow video to loop playback
      page4VideoElement.crossOrigin = 'anonymous';
      page4VideoElement.preload = 'auto'; // Ensure preloading

      // 創建音頻元素用於播放page4.mp3
      const page4AudioElement = document.createElement('audio');
      page4AudioElement.id = 'page4Audio';
      page4AudioElement.src = 'storytelling/page4.mp3';
      page4AudioElement.preload = 'auto';
      document.body.appendChild(page4AudioElement);

      // Add video source
      const source = document.createElement('source');
      source.src = 'storytelling/page4.mp4';
      source.type = 'video/mp4';
      page4VideoElement.appendChild(source);

      // Add to DOM
      document.body.appendChild(page4VideoElement);

      // Load video
      page4VideoElement.load();

      // When video has loaded enough data
      page4VideoElement.addEventListener('canplaythrough', function onCanPlay() {
        console.log('Page4 video ready to play');

        // Create video texture (but don't play yet)
        if (!page4VideoTexture) {
          page4VideoTexture = new THREE.VideoTexture(page4VideoElement);
          page4VideoTexture.minFilter = THREE.LinearFilter;
          page4VideoTexture.magFilter = THREE.LinearFilter;
          page4VideoTexture.format = THREE.RGBAFormat;
          page4VideoTexture.encoding = THREE.sRGBEncoding;
          page4VideoTexture.generateMipmaps = false;
        }

        // Remove event listener to avoid duplicate calls
        page4VideoElement.removeEventListener('canplaythrough', onCanPlay);
      });

      // Add error handling
      page4VideoElement.addEventListener('error', function (e) {
        console.error('Failed to load Page4 video:', e);
        // Load static image as fallback
        const loader = new THREE.TextureLoader();
        loader.load('storytelling/page4.jpg', function (texture) {
          page4VideoTexture = texture;
        });
      });

      console.log('Page4 video preloading started');
    }

    // Preload page5 video
    function preloadPage5Video() {
      // Create hidden video element
      page5VideoElement = document.createElement('video');
      page5VideoElement.id = 'page5Video';
      page5VideoElement.style.display = 'none';
      page5VideoElement.muted = true;
      page5VideoElement.playsInline = true;
      page5VideoElement.loop = true; // Allow video to loop playback
      page5VideoElement.crossOrigin = 'anonymous';
      page5VideoElement.preload = 'auto'; // Ensure preloading

      // 創建音頻元素用於播放page5.mp3
      const page5AudioElement = document.createElement('audio');
      page5AudioElement.id = 'page5Audio';
      page5AudioElement.src = 'storytelling/page5.mp3';
      page5AudioElement.preload = 'auto';
      document.body.appendChild(page5AudioElement);

      // Add video source
      const source = document.createElement('source');
      source.src = 'storytelling/page5.mp4';
      source.type = 'video/mp4';
      page5VideoElement.appendChild(source);

      // Add to DOM
      document.body.appendChild(page5VideoElement);

      // Load video
      page5VideoElement.load();

      // When video has loaded enough data
      page5VideoElement.addEventListener('canplaythrough', function onCanPlay() {
        console.log('Page5 video ready to play');

        // Create video texture (but don't play yet)
        if (!page5VideoTexture) {
          page5VideoTexture = new THREE.VideoTexture(page5VideoElement);
          page5VideoTexture.minFilter = THREE.LinearFilter;
          page5VideoTexture.magFilter = THREE.LinearFilter;
          page5VideoTexture.format = THREE.RGBAFormat;
          page5VideoTexture.encoding = THREE.sRGBEncoding;
          page5VideoTexture.generateMipmaps = false;
        }

        // Remove event listener to avoid duplicate calls
        page5VideoElement.removeEventListener('canplaythrough', onCanPlay);
      });

      // Add error handling
      page5VideoElement.addEventListener('error', function (e) {
        console.error('Failed to load Page5 video:', e);
        // Load static image as fallback
        const loader = new THREE.TextureLoader();
        loader.load('storytelling/page5.jpg', function (texture) {
          page5VideoTexture = texture;
        });
      });

      console.log('Page5 video preloading started');
    }

    // Preload page6 video
    function preloadPage6Video() {
      // Create hidden video element
      page6VideoElement = document.createElement('video');
      page6VideoElement.id = 'page6Video';
      page6VideoElement.style.display = 'none';
      page6VideoElement.muted = true;
      page6VideoElement.playsInline = true;
      page6VideoElement.loop = true; // Allow video to loop playback
      page6VideoElement.crossOrigin = 'anonymous';
      page6VideoElement.preload = 'auto'; // Ensure preloading

      // 創建音頻元素用於播放page6.mp3
      const page6AudioElement = document.createElement('audio');
      page6AudioElement.id = 'page6Audio';
      page6AudioElement.src = 'storytelling/page6.mp3';
      page6AudioElement.preload = 'auto';
      document.body.appendChild(page6AudioElement);

      // Add video source
      const source = document.createElement('source');
      source.src = 'storytelling/page6.mp4';
      source.type = 'video/mp4';
      page6VideoElement.appendChild(source);

      // Add to DOM
      document.body.appendChild(page6VideoElement);

      // Load video
      page6VideoElement.load();

      // When video has loaded enough data
      page6VideoElement.addEventListener('canplaythrough', function onCanPlay() {
        console.log('Page6 video ready to play');

        // Create video texture (but don't play yet)
        if (!page6VideoTexture) {
          page6VideoTexture = new THREE.VideoTexture(page6VideoElement);
          page6VideoTexture.minFilter = THREE.LinearFilter;
          page6VideoTexture.magFilter = THREE.LinearFilter;
          page6VideoTexture.format = THREE.RGBAFormat;
          page6VideoTexture.encoding = THREE.sRGBEncoding;
          page6VideoTexture.generateMipmaps = false;
        }

        // Remove event listener to avoid duplicate calls
        page6VideoElement.removeEventListener('canplaythrough', onCanPlay);
      });

      // Add error handling
      page6VideoElement.addEventListener('error', function (e) {
        console.error('Failed to load Page6 video:', e);
        // Load static image as fallback
        const loader = new THREE.TextureLoader();
        loader.load('storytelling/page6.jpg', function (texture) {
          page6VideoTexture = texture;
        });
      });

      console.log('Page6 video preloading started');
    }

    // Preload cover video
    function preloadCoverVideo() {
      // Create hidden video element
      coverVideoElement = document.createElement('video');
      coverVideoElement.id = 'coverVideo';
      coverVideoElement.style.display = 'none';
      coverVideoElement.muted = true;
      coverVideoElement.playsInline = true;
      coverVideoElement.loop = true; // Loop playback
      coverVideoElement.crossOrigin = 'anonymous';
      coverVideoElement.preload = 'auto';

      // 創建音頻元素用於播放cover.mp3
      const coverAudioElement = document.createElement('audio');
      coverAudioElement.id = 'coverAudio';
      coverAudioElement.src = 'storytelling/cover.mp3';
      coverAudioElement.preload = 'auto';
      document.body.appendChild(coverAudioElement);

      // Add video source
      const source = document.createElement('source');
      source.src = 'storytelling/cover.mp4';
      source.type = 'video/mp4';
      coverVideoElement.appendChild(source);

      // Add to DOM
      document.body.appendChild(coverVideoElement);

      // Load video
      coverVideoElement.load();

      // 監聽視頻播放事件，播放音頻
      coverVideoElement.addEventListener('play', function() {
        const coverAudio = document.getElementById('coverAudio');
        if (coverAudio) {
          coverAudio.currentTime = 0;
          coverAudio.play().catch(e => console.error('無法播放cover音頻:', e));
          
          // 降低背景音乐音量
          if (bgMusicElement) {
            bgMusicElement.volume = 0.05; // 从0.1降低到0.05
          }
        }
      });

      // Add load success event
      coverVideoElement.addEventListener('canplaythrough', function onCanPlay() {
        console.log('Cover video loaded, ready to play');

        // Create video texture
        if (!coverVideoTexture) {
          coverVideoTexture = new THREE.VideoTexture(coverVideoElement);
          coverVideoTexture.minFilter = THREE.LinearFilter;
          coverVideoTexture.magFilter = THREE.LinearFilter;
          coverVideoTexture.format = THREE.RGBAFormat;
          coverVideoTexture.encoding = THREE.sRGBEncoding;
          coverVideoTexture.generateMipmaps = false;

          // Create cover mesh
          const height = 5.5;
          const width = height * (2035 / 2044);

          const material = new THREE.MeshBasicMaterial({
            map: coverVideoTexture,
            side: THREE.DoubleSide,
            transparent: true,
          });

          const geometry = new THREE.PlaneGeometry(width, height);
          coverMesh = new THREE.Mesh(geometry, material);
          coverMesh.position.set(0, 0, 2); // Place cover in front center position
          coverMesh.scale.set(1.3, 1.3, 1.3); // Initial cover slightly enlarged
          coverMesh.userData = { type: 'cover' };
          bookContainer.add(coverMesh);

          // Save original position and scale of cover for reference by subsequent pages
          window.coverOriginalPosition = { x: 0, y: 0, z: 2 };
          window.coverOriginalScale = { x: 1.3, y: 1.3, z: 1.3 };

          // Save original transform of cover
          saveOriginalTransform(coverMesh);

          coverVideoElement.play().catch(e => {
            console.error('Unable to play cover video:', e);
          });

          console.log('Cover video mesh created');
        }

        // Remove event listener to avoid duplicate calls
        coverVideoElement.removeEventListener('canplaythrough', onCanPlay);
      });

      // Add error handling
      coverVideoElement.addEventListener('error', function (e) {
        console.error('Cover video loading failed:', e);
        // Load static image as fallback
        const loader = new THREE.TextureLoader();
        loader.load('storytelling/cover.jpg', function (texture) {
          coverVideoTexture = texture;

          // Create cover mesh
          const height = 5.5;
          const width = height * (2035 / 2044);

          const material = new THREE.MeshBasicMaterial({
            map: coverVideoTexture,
            side: THREE.DoubleSide,
            transparent: true,
          });

          const geometry = new THREE.PlaneGeometry(width, height);
          coverMesh = new THREE.Mesh(geometry, material);
          coverMesh.position.set(0, 0, 2); // Place cover in front center position
          coverMesh.scale.set(1.3, 1.3, 1.3); // Initial cover slightly enlarged
          coverMesh.userData = { type: 'cover' };
          bookContainer.add(coverMesh);

          // Save original position and scale of cover for reference by subsequent pages
          window.coverOriginalPosition = { x: 0, y: 0, z: 2 };
          window.coverOriginalScale = { x: 1.3, y: 1.3, z: 1.3 };

          // Save original transform of cover
          saveOriginalTransform(coverMesh);

          console.log('Cover image mesh created');
        });
      });

      console.log('Cover video preloading started');
    }

    // Modify cover slide animation, implement cover shrinking and moving left, page1 enlarging and showing
    function slideCoverAnimation() {
      console.log("Starting cover slide animation");
      isAnimating = true;

      // 停止封面音頻播放
      const coverAudio = document.getElementById('coverAudio');
      if (coverAudio) {
        coverAudio.pause();
        coverAudio.currentTime = 0;
      }

      // Reset focus state
      focusedPage = null;

      // Get initial display position and size of cover
      const coverPos = window.coverOriginalPosition;
      const coverScale = window.coverOriginalScale;

      // If pageMesh already exists, remove it first
      if (pageMesh) {
        bookContainer.remove(pageMesh);
        pageMesh = null;
      }

      // Create page1 video plane
      const height = 5.5;
      const width = height * (2035 / 2044);

      const material = new THREE.MeshBasicMaterial({
        map: page1VideoTexture,
        side: THREE.DoubleSide,
        transparent: true,
        toneMapped: false
      });

      const geometry = new THREE.PlaneGeometry(width, height);
      pageMesh = new THREE.Mesh(geometry, material);

      // Initial position set to right side for right-to-left page turning
      pageMesh.position.set(7, 0, -1);
      pageMesh.scale.set(1, 1, 1);
      pageMesh.rotation.y = 0.2; // Initial slight rotation
      pageMesh.userData = { type: 'page1' };
      pageMesh.visible = true;
      bookContainer.add(pageMesh);

      // Start playing page1 video
      if (page1VideoElement) {
        page1VideoElement.currentTime = 0;
        page1VideoElement.play().catch(err => {
          console.error('Unable to play page1 video:', err);
        });
        
        // 播放page1音頻
        const page1Audio = document.getElementById('page1Audio');
        if (page1Audio) {
          page1Audio.currentTime = 0;
          page1Audio.play().catch(e => console.error('無法播放page1音頻:', e));
        }
      }

      // Create a spine object, fixed on the left
      const spineGeometry = new THREE.BoxGeometry(0.2, height, 0.3);
      const spineMaterial = new THREE.MeshBasicMaterial({ color: 0x555555 });
      const spine = new THREE.Mesh(spineGeometry, spineMaterial);
      spine.position.set(-width / 2 - 0.1, 0, 0); // Fixed at left edge
      pageMesh.add(spine);

      // Cover leftward rotation animation (around spine)
      gsap.to(coverMesh.position, {
        x: -7, // Move to left position
        y: 0,
        z: -2, // Move backward
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Cover shrink leftward
      gsap.to(coverMesh.scale, {
        x: 0.9,
        y: 0.9,
        z: 0.9,
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Add cover rotation effect
      gsap.to(coverMesh.rotation, {
        y: -0.2, // Slight left rotation
        duration: 1.2,
        ease: "power2.inOut"
      });

      // First page right-to-left turning animation
      gsap.to(pageMesh.position, {
        x: coverPos.x, // Move to center position
        y: coverPos.y,
        z: coverPos.z,
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2 // Slight delay
      });

      // First page scales to original cover size
      gsap.to(pageMesh.scale, {
        x: coverScale.x,
        y: coverScale.y,
        z: coverScale.z,
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2
      });

      // First page rotates to face front
      gsap.to(pageMesh.rotation, {
        y: 0, // Rotate back to front
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2,
        onComplete: function () {
          storyShown = true;
          isAnimating = false;
          currentPage = 1;

          // Set each page to correct visibility
          if (coverMesh) coverMesh.visible = true;
          if (pageMesh) pageMesh.visible = true;
          if (page2Mesh) page2Mesh.visible = false;

          // Save original transform of first page
          saveOriginalTransform(pageMesh);

          // To maintain layer relationship, ensure page1 is on top
          bookContainer.remove(pageMesh);
          bookContainer.add(pageMesh);

          console.log("Cover slide animation complete, current page:", currentPage);

          // 更新页面可见性和游戏提示按钮
          updatePagesVisibility();
        }
      });

      // Simultaneously move camera slightly to better observe the entire scene
      gsap.to(camera.position, {
        x: 0,
        y: 2,
        z: 12,
        duration: 1.5,
        ease: "power1.inOut"
      });
    }

    // Add animation for turning to the second page
    function turnToPage2Animation() {
      if (isAnimating) return;

      isAnimating = true;
      currentPage = 2; // Set current page to the second page

      // 停止page1音頻播放
      const page1Audio = document.getElementById('page1Audio');
      if (page1Audio) {
        page1Audio.pause();
        page1Audio.currentTime = 0;
      }

      // Reset focus state
      focusedPage = null;

      // Get initial display position and size of cover
      const coverPos = window.coverOriginalPosition;
      const coverScale = window.coverOriginalScale;

      // If page2Mesh already exists, remove it first
      if (page2Mesh) {
        bookContainer.remove(page2Mesh);
        page2Mesh = null;
      }

      // Create a new page2 plane
      const height = 5.5;
      const width = height * (2035 / 2044);

      const material = new THREE.MeshBasicMaterial({
        map: page2VideoTexture,
        side: THREE.DoubleSide,
        transparent: true,
        toneMapped: false,
      });

      const geometry = new THREE.PlaneGeometry(width, height);
      page2Mesh = new THREE.Mesh(geometry, material);

      // Initial position set to right side for right-to-left page turning
      page2Mesh.position.set(7, 0, -1);
      page2Mesh.scale.set(1, 1, 1);
      page2Mesh.rotation.y = 0.2; // Initial slight rotation
      page2Mesh.userData = { type: 'page2' };
      page2Mesh.visible = true;
      bookContainer.add(page2Mesh);

      // Create a spine object, fixed on the left
      const spineGeometry = new THREE.BoxGeometry(0.2, height, 0.3);
      const spineMaterial = new THREE.MeshBasicMaterial({ color: 0x555555 });
      const spine = new THREE.Mesh(spineGeometry, spineMaterial);
      spine.position.set(-width / 2 - 0.1, 0, 0); // Fixed at left edge
      page2Mesh.add(spine);

      // Reset and play page2 video
      if (page2VideoElement) {
        page2VideoElement.currentTime = 0;
        page2VideoElement.volume = 0;
        page2VideoElement.muted = true;
        page2VideoElement.play().catch(err => {
          console.error('Unable to play Page2 video:', err);
        });
        
        // 播放page2音頻
        const page2Audio = document.getElementById('page2Audio');
        if (page2Audio) {
          page2Audio.currentTime = 0;
          page2Audio.play().catch(e => console.error('無法播放page2音頻:', e));
        }
      }

      // Create page1 left movement animation
      gsap.to(pageMesh.position, {
        x: -7, // Move to left position
        y: 0,
        z: -2, // Move backward
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Page1 shrinks
      gsap.to(pageMesh.scale, {
        x: 0.9,
        y: 0.9,
        z: 0.9,
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Add Page1 rotation
      gsap.to(pageMesh.rotation, {
        y: -0.2, // Slight left rotation
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Page2 right-to-left page turning animation
      gsap.to(page2Mesh.position, {
        x: coverPos.x, // Move to center position
        y: coverPos.y,
        z: coverPos.z,
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2 // Slight delay
      });

      // Page2 scales to original cover size
      gsap.to(page2Mesh.scale, {
        x: coverScale.x,
        y: coverScale.y,
        z: coverScale.z,
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2,
      });

      // Page2 rotates to face front
      gsap.to(page2Mesh.rotation, {
        y: 0, // Rotate back to front
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2,
        onComplete: function () {
          // Save page2's original transform
          saveOriginalTransform(page2Mesh);

          // After animation completes, add to render queue last to ensure it's on top
          bookContainer.remove(page2Mesh);
          bookContainer.add(page2Mesh);

          isAnimating = false;
          
          // 更新页面可见性和游戏提示按钮
          updatePagesVisibility();
          
          console.log('Turned to page2 video complete, can click to continue to page3');
        }
      });

      // Camera animation stays consistent with cover animation
      gsap.to(camera.position, {
        x: 0,
        y: 2,
        z: 12,
        duration: 1.5,
        ease: "power1.inOut"
      });
    }

    // Add animation for turning to the third page
    function turnToPage3Animation() {
      if (isAnimating) return;

      isAnimating = true;
      currentPage = 3; // Set current page to the third page

      // 停止page2音頻播放
      const page2Audio = document.getElementById('page2Audio');
      if (page2Audio) {
        page2Audio.pause();
        page2Audio.currentTime = 0;
      }

      // Reset focus state
      focusedPage = null;

      // Get initial display position and size of cover
      const coverPos = window.coverOriginalPosition;
      const coverScale = window.coverOriginalScale;

      // If page3Mesh already exists, remove it first
      if (page3Mesh) {
        bookContainer.remove(page3Mesh);
        page3Mesh = null;
      }

      // Create a new page3 plane
      const height = 5.5;
      const width = height * (2035 / 2044);

      const material = new THREE.MeshBasicMaterial({
        map: page3VideoTexture,
        side: THREE.DoubleSide,
        transparent: true,
        toneMapped: false,
      });

      const geometry = new THREE.PlaneGeometry(width, height);
      page3Mesh = new THREE.Mesh(geometry, material);

      // Initial position set to right side for right-to-left page turning
      page3Mesh.position.set(7, 0, -1);
      page3Mesh.scale.set(1, 1, 1);
      page3Mesh.rotation.y = 0.2; // Initial slight rotation
      page3Mesh.userData = { type: 'page3' };
      page3Mesh.visible = true;
      bookContainer.add(page3Mesh);

      // Create a spine object, fixed on the left
      const spineGeometry = new THREE.BoxGeometry(0.2, height, 0.3);
      const spineMaterial = new THREE.MeshBasicMaterial({ color: 0x555555 });
      const spine = new THREE.Mesh(spineGeometry, spineMaterial);
      spine.position.set(-width / 2 - 0.1, 0, 0); // Fixed at left edge
      page3Mesh.add(spine);

      // Reset and play page3 video
      if (page3VideoElement) {
        page3VideoElement.currentTime = 0;
        page3VideoElement.volume = 0;
        page3VideoElement.muted = true;
        page3VideoElement.play().catch(err => {
          console.error('Unable to play Page3 video:', err);
        });
        
        // 播放page3音頻
        const page3Audio = document.getElementById('page3Audio');
        if (page3Audio) {
          page3Audio.currentTime = 0;
          page3Audio.play().catch(e => console.error('無法播放page3音頻:', e));
        }
      }

      // Create page2 left movement animation
      gsap.to(page2Mesh.position, {
        x: -7, // Move to left position
        y: 0,
        z: -2, // Move backward
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Page2 shrinks
      gsap.to(page2Mesh.scale, {
        x: 0.9,
        y: 0.9,
        z: 0.9,
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Add Page2 rotation
      gsap.to(page2Mesh.rotation, {
        y: -0.2, // Slight left rotation
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Page3 right-to-left page turning animation
      gsap.to(page3Mesh.position, {
        x: coverPos.x, // Move to center position
        y: coverPos.y,
        z: coverPos.z,
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2 // Slight delay
      });

      // Page3 scales to original cover size
      gsap.to(page3Mesh.scale, {
        x: coverScale.x,
        y: coverScale.y,
        z: coverScale.z,
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2,
      });

      // Page3 rotates to face front
      gsap.to(page3Mesh.rotation, {
        y: 0, // Rotate back to front
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2,
        onComplete: function () {
          // Save page3's original transform
          saveOriginalTransform(page3Mesh);

          // After animation completes, add to render queue last to ensure it's on top
          bookContainer.remove(page3Mesh);
          bookContainer.add(page3Mesh);

          isAnimating = false;
          
          // 更新页面可见性和游戏提示按钮
          updatePagesVisibility();
          
          console.log('Turned to page3 video complete, can click to continue to page4');
        }
      });

      // Camera animation stays consistent
      gsap.to(camera.position, {
        x: 0,
        y: 2,
        z: 12,
        duration: 1.5,
        ease: "power1.inOut"
      });
    }

    // Add animation for turning to the fourth page
    function turnToPage4Animation() {
      if (isAnimating) return;

      isAnimating = true;
      currentPage = 4; // Set current page to the fourth page

      // 停止page3音頻播放
      const page3Audio = document.getElementById('page3Audio');
      if (page3Audio) {
        page3Audio.pause();
        page3Audio.currentTime = 0;
      }

      // Reset focus state
      focusedPage = null;

      // Get initial display position and size of cover
      const coverPos = window.coverOriginalPosition;
      const coverScale = window.coverOriginalScale;

      // If page4Mesh already exists, remove it first
      if (page4Mesh) {
        bookContainer.remove(page4Mesh);
        page4Mesh = null;
      }

      // Create a new page4 plane
      const height = 5.5;
      const width = height * (2035 / 2044);

      const material = new THREE.MeshBasicMaterial({
        map: page4VideoTexture,
        side: THREE.DoubleSide,
        transparent: true,
        toneMapped: false,
      });

      const geometry = new THREE.PlaneGeometry(width, height);
      page4Mesh = new THREE.Mesh(geometry, material);

      // Initial position set to right side for right-to-left page turning
      page4Mesh.position.set(7, 0, -1);
      page4Mesh.scale.set(1, 1, 1);
      page4Mesh.rotation.y = 0.2; // Initial slight rotation
      page4Mesh.userData = { type: 'page4' };
      page4Mesh.visible = true;
      bookContainer.add(page4Mesh);

      // Create a spine object, fixed on the left
      const spineGeometry = new THREE.BoxGeometry(0.2, height, 0.3);
      const spineMaterial = new THREE.MeshBasicMaterial({ color: 0x555555 });
      const spine = new THREE.Mesh(spineGeometry, spineMaterial);
      spine.position.set(-width / 2 - 0.1, 0, 0); // Fixed at left edge
      page4Mesh.add(spine);

      // Reset and play page4 video
      if (page4VideoElement) {
        page4VideoElement.currentTime = 0;
        page4VideoElement.volume = 0;
        page4VideoElement.muted = true;
        page4VideoElement.play().catch(err => {
          console.error('Unable to play Page4 video:', err);
        });
        
        // 播放page4音頻
        const page4Audio = document.getElementById('page4Audio');
        if (page4Audio) {
          page4Audio.currentTime = 0;
          page4Audio.play().catch(e => console.error('無法播放page4音頻:', e));
        }
      }

      // Create page3 left movement animation
      gsap.to(page3Mesh.position, {
        x: -7, // Move to left position
        y: 0,
        z: -2, // Move backward
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Page3 shrinks
      gsap.to(page3Mesh.scale, {
        x: 0.9,
        y: 0.9,
        z: 0.9,
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Add Page3 rotation
      gsap.to(page3Mesh.rotation, {
        y: -0.2, // Slight left rotation
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Page4 right-to-left page turning animation
      gsap.to(page4Mesh.position, {
        x: coverPos.x, // Move to center position
        y: coverPos.y,
        z: coverPos.z,
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2 // Slight delay
      });

      // Page4 scales to original cover size
      gsap.to(page4Mesh.scale, {
        x: coverScale.x,
        y: coverScale.y,
        z: coverScale.z,
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2,
      });

      // Page4 rotates to face front
      gsap.to(page4Mesh.rotation, {
        y: 0, // Rotate back to front
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2,
        onComplete: function () {
          // Save page4's original transform
          saveOriginalTransform(page4Mesh);

          // After animation completes, add to render queue last to ensure it's on top
          bookContainer.remove(page4Mesh);
          bookContainer.add(page4Mesh);

          isAnimating = false;
          
          // 更新页面可见性和游戏提示按钮
          updatePagesVisibility();
          
          console.log('Turned to page4 video complete, can click to continue to page5');
        }
      });

      // Camera animation stays consistent
      gsap.to(camera.position, {
        x: 0,
        y: 2,
        z: 12,
        duration: 1.5,
        ease: "power1.inOut"
      });
    }

    // Add animation for turning to the fifth page
    function turnToPage5Animation() {
      if (isAnimating) return;

      isAnimating = true;
      currentPage = 5; // Set current page to the fifth page

      // 停止page4音頻播放
      const page4Audio = document.getElementById('page4Audio');
      if (page4Audio) {
        page4Audio.pause();
        page4Audio.currentTime = 0;
      }

      // Reset focus state
      focusedPage = null;

      // Get initial display position and size of cover
      const coverPos = window.coverOriginalPosition;
      const coverScale = window.coverOriginalScale;

      // If page5Mesh already exists, remove it first
      if (page5Mesh) {
        bookContainer.remove(page5Mesh);
        page5Mesh = null;
      }

      // Create a new page5 plane
      const height = 5.5;
      const width = height * (2035 / 2044);

      const material = new THREE.MeshBasicMaterial({
        map: page5VideoTexture,
        side: THREE.DoubleSide,
        transparent: true,
        toneMapped: false,
      });

      const geometry = new THREE.PlaneGeometry(width, height);
      page5Mesh = new THREE.Mesh(geometry, material);

      // Initial position set to right side for right-to-left page turning
      page5Mesh.position.set(7, 0, -1);
      page5Mesh.scale.set(1, 1, 1);
      page5Mesh.rotation.y = 0.2; // Initial slight rotation
      page5Mesh.userData = { type: 'page5' };
      page5Mesh.visible = true;
      bookContainer.add(page5Mesh);

      // Create a spine object, fixed on the left
      const spineGeometry = new THREE.BoxGeometry(0.2, height, 0.3);
      const spineMaterial = new THREE.MeshBasicMaterial({ color: 0x555555 });
      const spine = new THREE.Mesh(spineGeometry, spineMaterial);
      spine.position.set(-width / 2 - 0.1, 0, 0); // Fixed at left edge
      page5Mesh.add(spine);

      // Reset and play page5 video
      if (page5VideoElement) {
        page5VideoElement.currentTime = 0;
        page5VideoElement.volume = 0;
        page5VideoElement.muted = true;
        page5VideoElement.play().catch(err => {
          console.error('Unable to play Page5 video:', err);
        });
        
        // 播放page5音頻
        const page5Audio = document.getElementById('page5Audio');
        if (page5Audio) {
          page5Audio.currentTime = 0;
          page5Audio.play().catch(e => console.error('無法播放page5音頻:', e));
        }
      }

      // Create page4 left movement animation
      gsap.to(page4Mesh.position, {
        x: -7, // Move to left position
        y: 0,
        z: -2, // Move backward
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Page4 shrinks
      gsap.to(page4Mesh.scale, {
        x: 0.9,
        y: 0.9,
        z: 0.9,
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Add Page4 rotation
      gsap.to(page4Mesh.rotation, {
        y: -0.2, // Slight left rotation
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Page5 right-to-left page turning animation
      gsap.to(page5Mesh.position, {
        x: coverPos.x, // Move to center position
        y: coverPos.y,
        z: coverPos.z,
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2 // Slight delay
      });

      // Page5 scales to original cover size
      gsap.to(page5Mesh.scale, {
        x: coverScale.x,
        y: coverScale.y,
        z: coverScale.z,
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2,
      });

      // Page5 rotates to face front
      gsap.to(page5Mesh.rotation, {
        y: 0, // Rotate back to front
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2,
        onComplete: function () {
          // Save page5's original transform
          saveOriginalTransform(page5Mesh);

          // After animation completes, add to render queue last to ensure it's on top
          bookContainer.remove(page5Mesh);
          bookContainer.add(page5Mesh);

          isAnimating = false;
          
          // 更新页面可见性和游戏提示按钮
          updatePagesVisibility();
          
          console.log('Turned to page5 video complete, this is the last page');
        }
      });

      // Camera animation stays consistent
      gsap.to(camera.position, {
        x: 0,
        y: 2,
        z: 12,
        duration: 1.5,
        ease: "power1.inOut"
      });
    }

    // Add animation for turning to the sixth page
    function turnToPage6Animation() {
      if (isAnimating) return;

      isAnimating = true;
      currentPage = 6; // Set current page to the sixth page

      // 停止page5音頻播放
      const page5Audio = document.getElementById('page5Audio');
      if (page5Audio) {
        page5Audio.pause();
        page5Audio.currentTime = 0;
      }

      // Reset focus state
      focusedPage = null;

      // Get the initial display position and size of the cover
      const coverPos = window.coverOriginalPosition;
      const coverScale = window.coverOriginalScale;

      // If page6Mesh already exists, remove it first
      if (page6Mesh) {
        bookContainer.remove(page6Mesh);
        page6Mesh = null;
      }

      // Create a new page6 plane
      const height = 5.5;
      const width = height * (2035 / 2044);

      const material = new THREE.MeshBasicMaterial({
        map: page6VideoTexture,
        side: THREE.DoubleSide,
        transparent: true,
        toneMapped: false,
      });

      const geometry = new THREE.PlaneGeometry(width, height);
      page6Mesh = new THREE.Mesh(geometry, material);

      // Initial position set to right side for right-to-left page turning
      page6Mesh.position.set(7, 0, -1);
      page6Mesh.scale.set(1, 1, 1);
      page6Mesh.rotation.y = 0.2; // Initial slight rotation
      page6Mesh.userData = { type: 'page6' };
      page6Mesh.visible = true;
      bookContainer.add(page6Mesh);

      // Create a spine object, fixed on the left
      const spineGeometry = new THREE.BoxGeometry(0.2, height, 0.3);
      const spineMaterial = new THREE.MeshBasicMaterial({ color: 0x555555 });
      const spine = new THREE.Mesh(spineGeometry, spineMaterial);
      spine.position.set(-width / 2 - 0.1, 0, 0); // Fixed at left edge
      page6Mesh.add(spine);

      // Reset and play page6 video
      if (page6VideoElement) {
        page6VideoElement.currentTime = 0;
        page6VideoElement.volume = 0;
        page6VideoElement.muted = true;
        page6VideoElement.play().catch(err => {
          console.error('Unable to play Page6 video:', err);
        });
        
        // 播放page6音頻
        const page6Audio = document.getElementById('page6Audio');
        if (page6Audio) {
          page6Audio.currentTime = 0;
          page6Audio.play().catch(e => console.error('無法播放page6音頻:', e));
        }
      }

      // Create page5 left movement animation
      gsap.to(page5Mesh.position, {
        x: -7, // Move to left position
        y: 0,
        z: -2, // Move backward
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Page5 shrinks
      gsap.to(page5Mesh.scale, {
        x: 0.9,
        y: 0.9,
        z: 0.9,
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Add Page5 rotation
      gsap.to(page5Mesh.rotation, {
        y: -0.2, // Slight left rotation
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Page6 right-to-left page turning animation
      gsap.to(page6Mesh.position, {
        x: coverPos.x, // Move to center position
        y: coverPos.y,
        z: coverPos.z,
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2 // Slight delay
      });

      // Page6 scales to original cover size
      gsap.to(page6Mesh.scale, {
        x: coverScale.x,
        y: coverScale.y,
        z: coverScale.z,
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2,
      });

      // Page6 rotates to face front
      gsap.to(page6Mesh.rotation, {
        y: 0, // Rotate back to front
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2,
        onComplete: function () {
          // Save page6's original transform
          saveOriginalTransform(page6Mesh);

          // After animation completes, add to render queue last to ensure it's on top
          bookContainer.remove(page6Mesh);
          bookContainer.add(page6Mesh);

          // Add indicator to prompt user to click the last page to enter game
          createGameNavigationPrompt();

          isAnimating = false;
          console.log('Turned to page6 video complete, this is the last page');

          // 更新页面可见性和游戏提示按钮
          updatePagesVisibility();
        }
      });

      // Camera animation stays consistent
      gsap.to(camera.position, {
        x: 0,
        y: 2,
        z: 12,
        duration: 1.5,
        ease: "power1.inOut"
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      let delta = clock.getDelta();

      // Smooth camera movement
      if (!isAnimating && camera.position.z > camTargetZ) {
        camera.position.z -= delta * 2;
      }

      // Slight camera shake
      if (!isAnimating) {
        camera.position.y += Math.sin(clock.getElapsedTime() * 0.5) * 0.001;
        camera.position.x += Math.sin(clock.getElapsedTime() * 0.3) * 0.0005;
      }

      // Update background video texture
      if (activeVideoTexture && !activeVideoElement.paused) {
        activeVideoTexture.needsUpdate = true;
      }

      // Update all page video textures
      updateVideoMaterials();

      renderer.render(scene, camera);
    }

    // Update all page video textures
    function updateVideoMaterials() {
      // Update cover video material
      if (coverMesh && coverVideoTexture && coverVideoElement && !coverVideoElement.paused) {
        coverVideoTexture.needsUpdate = true;
      }

      // Update page1 video material
      if (pageMesh && page1VideoTexture && page1VideoElement && !page1VideoElement.paused) {
        page1VideoTexture.needsUpdate = true;
      }

      // Update page2 video material
      if (page2Mesh && page2VideoTexture && page2VideoElement && !page2VideoElement.paused) {
        page2VideoTexture.needsUpdate = true;
      }

      // Update page3 video material
      if (page3Mesh && page3VideoTexture && page3VideoElement && !page3VideoElement.paused) {
        page3VideoTexture.needsUpdate = true;
      }

      // Update page4 video material
      if (page4Mesh && page4VideoTexture && page4VideoElement && !page4VideoElement.paused) {
        page4VideoTexture.needsUpdate = true;
      }

      // Update page5 video material
      if (page5Mesh && page5VideoTexture && page5VideoElement && !page5VideoElement.paused) {
        page5VideoTexture.needsUpdate = true;
      }

      // Update page6 video material
      if (page6Mesh && page6VideoTexture && page6VideoElement && !page6VideoElement.paused) {
        page6VideoTexture.needsUpdate = true;
      }
    }

    // Handle page focus - zooming in and out of pages and jumping to corresponding pages when clicked
    // clickedObject: the clicked page object
    function handlePageFocus(clickedObject) {
      // If animation is in progress, ignore click
      if (isAnimating) return;

      console.log("Handling page focus, clicked object:", clickedObject.userData.type);

      // If clicked object is the currently focused (zoomed) object, perform reset operation, restoring all pages to normal size
      if (clickedObject === focusedPage) {
        resetAllPages();
        return;
      }

      // Jump directly to the corresponding page based on the clicked object's type
      if (clickedObject === coverMesh) {
        directResetToPage(0, coverMesh);
        return;
      } else if (clickedObject === pageMesh) {
        directResetToPage(1, pageMesh);
        return;
      } else if (clickedObject === page2Mesh) {
        directResetToPage(2, page2Mesh);
        return;
      } else if (clickedObject === page3Mesh) {
        directResetToPage(3, page3Mesh);
        return;
      } else if (clickedObject === page4Mesh) {
        directResetToPage(4, page4Mesh);
        return;
      } else if (clickedObject === page5Mesh) {
        directResetToPage(5, page5Mesh);
        return;
      } else if (clickedObject === page6Mesh) {
        directResetToPage(6, page6Mesh);
        return;
      }

      // This should not be reached, but for robustness, it's left in place
      console.warn("Unrecognized object processed:", clickedObject);
    }

    // Reset to initial cover state
    function resetToInitialCoverState() {
      console.log("Resetting to initial cover state");
      isAnimating = true;

      // Restore camera position
      gsap.to(camera.position, {
        x: 0,
        y: 2,
        z: camTargetZ,
        duration: 1,
        ease: "power2.inOut"
      });

      // Reset to cover state
      currentPage = 0;
      console.log("Current page set to cover (0)");

      // Set page visibility, only show cover
      if (coverMesh) coverMesh.visible = true;
      if (pageMesh) pageMesh.visible = false;
      if (page2Mesh) page2Mesh.visible = false;
      if (page3Mesh) page3Mesh.visible = false;
      if (page4Mesh) page4Mesh.visible = false;
      if (page5Mesh) page5Mesh.visible = false;
      if (page6Mesh) page6Mesh.visible = false;

      // Replay cover video
      if (coverVideoElement) {
        coverVideoElement.currentTime = 0;
        coverVideoElement.play().catch(e => console.error('Unable to replay cover video:', e));
        
        // 播放cover音頻
        const coverAudio = document.getElementById('coverAudio');
        if (coverAudio) {
          coverAudio.currentTime = 0;
          coverAudio.play().catch(e => console.error('無法播放cover音頻:', e));
        }
      }

      // Ensure cover is on top
      if (coverMesh) {
        // Move cover to initial position and set initial size
        gsap.to(coverMesh.position, {
          x: 0,
          y: 0,
          z: 2,
          duration: 1,
          ease: "power2.inOut"
        });

        gsap.to(coverMesh.scale, {
          x: 1.3,
          y: 1.3,
          z: 1.3,
          duration: 1,
          ease: "power2.inOut"
        });

        gsap.to(coverMesh.rotation, {
          y: 0,
          duration: 1,
          ease: "power2.inOut",
          onComplete: function () {
            bookContainer.remove(coverMesh);
            bookContainer.add(coverMesh);

            isAnimating = false;
            focusedPage = null;
            
            // 更新页面可见性和游戏提示按钮
            updatePagesVisibility();
            
            console.log('Cover state has been restored');
          }
        });
      }
    }

    // Change focus
    function changeFocus(newFocusPage) {
      // Move previously focused page back to its original position
      const oldFocusPage = focusedPage;


      // Ensure new selected page is on top
      bookContainer.remove(newFocusPage);
      bookContainer.add(newFocusPage);

      // Old page moves to the left and shrinks to 0.9x
      gsap.to(oldFocusPage.position, {
        x: -4, // Move to the left
        y: 0, // Lower position
        z: -5, // Move backward
        duration: 1,
        ease: "power2.out"
      });

      // Old page shrinks to 0.9x
      gsap.to(oldFocusPage.scale, {
        x: 0.9,
        y: 0.9,
        z: 0.9,
        duration: 1,
        ease: "power2.out"
      });

      // Old page slightly rotates
      gsap.to(oldFocusPage.rotation, {
        y: -0.2, // Slight left rotation
        duration: 1,
        ease: "power2.out"
      });

      // Save new page's original state and set it as focused
      saveOriginalTransform(newFocusPage);
      focusedPage = newFocusPage;

      // New page zooms to 1.8x and centers
      gsap.to(newFocusPage.position, {
        x: 0,
        y: 2,
        z: 2, // Move forward
        duration: 1,
        ease: "power2.out"
      });

      gsap.to(newFocusPage.scale, {
        x: 1.8,
        y: 1.8,
        z: 1.8,
        duration: 1,
        ease: "back.out(1.1)"
      });

      // Restore rotation angle to 0
      gsap.to(newFocusPage.rotation, {
        y: 0,
        duration: 1,
        ease: "power2.out",
        onComplete: function () {
          isAnimating = false;
        }
      });
    }

    // Reset all pages to their original state
    function resetAllPages() {
      // If there is no focused page, no need to reset
      if (!focusedPage) {
        console.log("No focused page, no need to reset");
        return;
      }

      // Prevent calling during animation
      if (isAnimating) {
        console.log("Animation in progress, ignoring reset request");
        return;
      }

      console.log("Starting to reset all pages");

      // Save current page number
      const savedCurrentPage = currentPage;
      console.log("Recording current page state:", savedCurrentPage);

      // Cancel focus state
      focusedPage = null;

      // Select the corresponding mesh object based on current page
      let targetMesh = null;

      switch (savedCurrentPage) {
        case 0:
          targetMesh = coverMesh;
          break;
        case 1:
          targetMesh = pageMesh;
          break;
        case 2:
          targetMesh = page2Mesh;
          break;
        case 3:
          targetMesh = page3Mesh;
          break;
        case 4:
          targetMesh = page4Mesh;
          break;
        case 5:
          targetMesh = page5Mesh;
          break;
        case 6:
          targetMesh = page6Mesh;
          break;
      }

      // Call directResetToPage to complete the reset
      if (targetMesh) {
        directResetToPage(savedCurrentPage, targetMesh);
      } else {
        console.error("Unable to find target page, reset failed");
      }
    }

    // Save original transform of an object
    function saveOriginalTransform(object) {
      const id = object.uuid;
      if (!originalPositions[id]) {
        originalPositions[id] = {
          x: object.position.x,
          y: object.position.y,
          z: object.position.z
        };
      }

      if (!originalScales[id]) {
        originalScales[id] = {
          x: object.scale.x,
          y: object.scale.y,
          z: object.scale.z
        };
      }

      // Also save rotation information
      if (!object.userData.originalRotation) {
        object.userData.originalRotation = {
          x: object.rotation.x,
          y: object.rotation.y,
          z: object.rotation.z
        };
      }
    }

    // Get all currently visible pages
    function getAllVisiblePages() {
      const pages = [];
      if (coverMesh && coverMesh.visible) pages.push(coverMesh);
      if (pageMesh && pageMesh.visible) pages.push(pageMesh);
      if (page2Mesh && page2Mesh.visible) pages.push(page2Mesh);
      if (page3Mesh && page3Mesh.visible) pages.push(page3Mesh);
      if (page4Mesh && page4Mesh.visible) pages.push(page4Mesh);
      if (page5Mesh && page5Mesh.visible) pages.push(page5Mesh);
      if (page6Mesh && page6Mesh.visible) pages.push(page6Mesh);
      return pages;
    }

    // Add a simple debug function to check page positions in the console
    function logPagePositions() {
      console.log('--- PAGE POSITION STATUS ---');
      if (coverMesh) console.log('Cover:', coverMesh.position, coverMesh.scale);
      if (pageMesh) console.log('Page 1:', pageMesh.position, pageMesh.scale);
      if (page2Mesh) console.log('Page 2:', page2Mesh.position, page2Mesh.scale);
      if (page3Mesh) console.log('Page 3:', page3Mesh.position, page3Mesh.scale);
      if (page4Mesh) console.log('Page 4:', page4Mesh.position, page4Mesh.scale);
      if (page5Mesh) console.log('Page 5:', page5Mesh.position, page5Mesh.scale);
      if (page6Mesh) console.log('Page 6:', page6Mesh.position, page6Mesh.scale);
      console.log('Current focused page:', focusedPage ? focusedPage.userData.type || 'unknown' : 'none');
      console.log('---------------------------');
    }

    // Focus on a page
    function focusPage(page) {
      // Store original position and scale
      focusedPage = page;
      saveOriginalTransform(page);

      // Store original transform of other pages
      const otherPages = getAllVisiblePages().filter(p => p !== page);
      otherPages.forEach(p => saveOriginalTransform(p));

      // Ensure selected page is always on top
      bookContainer.remove(page);
      bookContainer.add(page); // Re-adding will render it last, i.e., on top

      // Zoom in on selected page and center it
      gsap.to(page.position, {
        x: 0, // Horizontal center
        y: 2, // Vertical position remains unchanged
        z: 2, // Move forward to ensure it's in front of other pages
        duration: 1,
        ease: "power2.out"
      });

      // Zoom to 1.8x
      gsap.to(page.scale, {
        x: 1.8,
        y: 1.8,
        z: 1.8,
        duration: 1,
        ease: "back.out(1.1)"
      });

      // Ensure rotation angle is 0, so the page faces the user
      gsap.to(page.rotation, {
        y: 0,
        duration: 0.8,
        ease: "power2.out"
      });

      // Move other pages back and shrink to 0.9x, ensuring selected page is covered
      otherPages.forEach((otherPage, index) => {
        // Calculate position to evenly distribute behind main pages
        const angle = (index / otherPages.length) * Math.PI * 0.6; // Distribution less than half circle, concentrated on left side
        const offsetX = -4 - Math.sin(angle) * 3; // Negative value moves page to left side
        const offsetZ = -3 - Math.cos(angle) * 2; // All pages behind

        gsap.to(otherPage.position, {
          x: offsetX,
          y: 0, // Slightly lower position
          z: offsetZ, // Move backward
          duration: 1,
          ease: "power2.out"
        });

        // Shrink to 0.9x
        gsap.to(otherPage.scale, {
          x: 0.9,
          y: 0.9,
          z: 0.9,
          duration: 1,
          ease: "power2.out"
        });

        // Add slight rotation for added depth
        gsap.to(otherPage.rotation, {
          y: -0.2, // Left rotation
          duration: 1,
          ease: "power2.out"
        });
      });

      // Adjust camera position for optimal viewing angle
      gsap.to(camera.position, {
        x: 0,
        y: 2,
        z: 10, // Slightly farther distance for better overall visual effect
        duration: 1,
        ease: "power2.inOut",
        onComplete: function () {
          isAnimating = false;
          logPagePositions();
        }
      });
    }

    // Update visibility of all pages
    function updatePagesVisibility() {
      console.log("Updating page visibility, current page:", currentPage);
      // Set visibility based on current page number
      if (currentPage === 0) { // Cover
        if (coverMesh) coverMesh.visible = true;
        if (pageMesh) pageMesh.visible = false;
        if (page2Mesh) page2Mesh.visible = false;
        if (page3Mesh) page3Mesh.visible = false;
        if (page4Mesh) page4Mesh.visible = false;
        if (page5Mesh) page5Mesh.visible = false;
        if (page6Mesh) page6Mesh.visible = false;
      } else if (currentPage === 1) { // First page
        if (coverMesh) coverMesh.visible = true;
        if (pageMesh) pageMesh.visible = true;
        if (page2Mesh) page2Mesh.visible = false;
        if (page3Mesh) page3Mesh.visible = false;
        if (page4Mesh) page4Mesh.visible = false;
        if (page5Mesh) page5Mesh.visible = false;
        if (page6Mesh) page6Mesh.visible = false;
      } else if (currentPage === 2) { // Second page
        if (coverMesh) coverMesh.visible = true;
        if (pageMesh) pageMesh.visible = true;
        if (page2Mesh) page2Mesh.visible = true;
        if (page3Mesh) page3Mesh.visible = false;
        if (page4Mesh) page4Mesh.visible = false;
        if (page5Mesh) page5Mesh.visible = false;
        if (page6Mesh) page6Mesh.visible = false;
      } else if (currentPage === 3) { // Third page
        if (coverMesh) coverMesh.visible = true;
        if (pageMesh) pageMesh.visible = true;
        if (page2Mesh) page2Mesh.visible = true;
        if (page3Mesh) page3Mesh.visible = true;
        if (page4Mesh) page4Mesh.visible = false;
        if (page5Mesh) page5Mesh.visible = false;
        if (page6Mesh) page6Mesh.visible = false;
      } else if (currentPage === 4) { // Fourth page
        if (coverMesh) coverMesh.visible = true;
        if (pageMesh) pageMesh.visible = true;
        if (page2Mesh) page2Mesh.visible = true;
        if (page3Mesh) page3Mesh.visible = true;
        if (page4Mesh) page4Mesh.visible = true;
        if (page5Mesh) page5Mesh.visible = false;
        if (page6Mesh) page6Mesh.visible = false;
      } else if (currentPage === 5) { // Fifth page
        if (coverMesh) coverMesh.visible = true;
        if (pageMesh) pageMesh.visible = true;
        if (page2Mesh) page2Mesh.visible = true;
        if (page3Mesh) page3Mesh.visible = true;
        if (page4Mesh) page4Mesh.visible = true;
        if (page5Mesh) page5Mesh.visible = true;
        if (page6Mesh) page6Mesh.visible = false;
      } else if (currentPage === 6) { // Sixth page
        if (coverMesh) coverMesh.visible = true;
        if (pageMesh) pageMesh.visible = true;
        if (page2Mesh) page2Mesh.visible = true;
        if (page3Mesh) page3Mesh.visible = true;
        if (page4Mesh) page4Mesh.visible = true;
        if (page5Mesh) page5Mesh.visible = true;
        if (page6Mesh) page6Mesh.visible = true;
      }
      
      // 根据当前页面更新游戏提示按钮
      createGameNavigationPrompt();
    }

    // Directly restore to cover state without using resetToInitialCoverState function (to avoid recursion)
    function directRestoreCoverState() {
      console.log("Directly restoring to cover state");

      // Set current page to cover
      currentPage = 0;

      // Set page visibility, only show cover
      if (coverMesh) {
        coverMesh.visible = true;

        // Restore cover position and size
        gsap.to(coverMesh.position, {
          x: 0,
          y: 0,
          z: 2,
          duration: 1,
          ease: "power2.inOut"
        });

        gsap.to(coverMesh.scale, {
          x: 1.3,
          y: 1.3,
          z: 1.3,
          duration: 1,
          ease: "power2.inOut"
        });

        gsap.to(coverMesh.rotation, {
          y: 0,
          duration: 1,
          ease: "power2.inOut"
        });

        // Ensure cover is on top
        bookContainer.remove(coverMesh);
        bookContainer.add(coverMesh);
      }

      // Hide other pages
      if (pageMesh) pageMesh.visible = false;
      if (page2Mesh) page2Mesh.visible = false;
      if (page3Mesh) page3Mesh.visible = false;
      if (page4Mesh) page4Mesh.visible = false;
      if (page5Mesh) page5Mesh.visible = false;
      if (page6Mesh) page6Mesh.visible = false;

      // Play cover video
      if (coverVideoElement) {
        coverVideoElement.currentTime = 0;
        coverVideoElement.play().catch(e => console.error('Unable to play cover video:', e));
      }

      // Adjust camera position
      gsap.to(camera.position, {
        x: 0,
        y: 2,
        z: camTargetZ,
        duration: 1,
        ease: "power2.inOut"
      });

      // 更新页面可见性和游戏提示按钮
      updatePagesVisibility();
    }

    // Directly reset to specified page
    function directResetToPage(pageNum, targetMesh) {
      // Add full debug log
      console.log("===== STARTING PAGE RESET =====");
      console.log("Target page:", pageNum, "Target mesh:", targetMesh ? targetMesh.userData.type : "none");
      console.log("Current page:", currentPage, "Focused page:", focusedPage ? focusedPage.userData.type : "none");

      // If animation is in progress, ignore reset request
      if (isAnimating) {
        console.log("Animation in progress, ignoring direct reset request");
        return;
      }

      // Ensure pageNum is within valid range
      if (pageNum < 0 || pageNum > 6) {
        console.error("Invalid page number:", pageNum);
        return;
      }

      // Ensure targetMesh is valid
      if (!targetMesh) {
        console.error("Invalid target mesh object");
        return;
      }

      isAnimating = true;
      console.log("Starting reset to page:", pageNum, "Target mesh type:", targetMesh.userData.type);

      // Set current page - ensure pageNum matches targetMesh type
      if (targetMesh === coverMesh) {
        pageNum = 0;
      } else if (targetMesh === pageMesh) {
        pageNum = 1;
      } else if (targetMesh === page2Mesh) {
        pageNum = 2;
      } else if (targetMesh === page3Mesh) {
        pageNum = 3;
      } else if (targetMesh === page4Mesh) {
        pageNum = 4;
      } else if (targetMesh === page5Mesh) {
        pageNum = 5;
      } else if (targetMesh === page6Mesh) {
        pageNum = 6;
      }

      // Update current page number
      currentPage = pageNum;
      console.log("Actual target page:", pageNum);

      // Clear focus state
      if (focusedPage) {
        console.log("Clearing focus state:", focusedPage.userData.type);
        focusedPage = null;
      }

      // Get reference position and size
      const coverPos = window.coverOriginalPosition || { x: 0, y: 0, z: 2 };
      const coverScale = window.coverOriginalScale || { x: 1.3, y: 1.3, z: 1.3 };
      console.log("Reference position:", coverPos, "Reference scale:", coverScale);

      // Stop all videos
      stopAllVideos();

      // Special handling for cover page
      if (pageNum === 0) {
        console.log("Resetting to cover page");
        // Cover page, only show cover
        if (coverMesh) coverMesh.visible = true;
        if (pageMesh) pageMesh.visible = false;
        if (page2Mesh) page2Mesh.visible = false;
        if (page3Mesh) page3Mesh.visible = false;
        if (page4Mesh) page4Mesh.visible = false;
        if (page5Mesh) page5Mesh.visible = false;
        if (page6Mesh) page6Mesh.visible = false;

        if (coverMesh) {
          gsap.to(coverMesh.position, {
            x: 0,
            y: 0,
            z: 2,
            duration: 1,
            ease: "power2.inOut"
          });

          gsap.to(coverMesh.scale, {
            x: 1.3,
            y: 1.3,
            z: 1.3,
            duration: 1,
            ease: "power2.inOut"
          });

          gsap.to(coverMesh.rotation, {
            y: 0,
            duration: 1,
            ease: "power2.inOut"
          });
        }

        // Play cover video
        if (coverVideoElement) {
          coverVideoElement.currentTime = 0;
          coverVideoElement.play().catch(e => console.error('Unable to play cover video:', e));
          
          // 播放cover音頻
          const coverAudio = document.getElementById('coverAudio');
          if (coverAudio) {
            coverAudio.currentTime = 0;
            coverAudio.play().catch(e => console.error('無法播放cover音頻:', e));
          }
        }

        // Adjust camera position
        gsap.to(camera.position, {
          x: 0,
          y: 2,
          z: 12,
          duration: 1,
          ease: "power2.inOut",
          onComplete: function () {
            isAnimating = false;
            console.log("Cover page reset complete");
            logPagePositions();
            
            // 更新页面可见性和游戏提示按钮状态
            updatePagesVisibility();
          }
        });

        return;
      }

      // Non-cover page processing
      console.log("Processing non-cover page:", pageNum);

      // Set page visibility - ensure current and previous pages are visible
      console.log("Setting page visibility:");
      if (coverMesh) {
        coverMesh.visible = true;
        console.log("- Cover visible");
      }
      if (pageMesh) {
        pageMesh.visible = pageNum >= 1;
        console.log(`- First page ${pageNum >= 1 ? 'visible' : 'not visible'}`);
      }
      if (page2Mesh) {
        page2Mesh.visible = pageNum >= 2;
        console.log(`- Second page ${pageNum >= 2 ? 'visible' : 'not visible'}`);
      }
      if (page3Mesh) {
        page3Mesh.visible = pageNum >= 3;
        console.log(`- Third page ${pageNum >= 3 ? 'visible' : 'not visible'}`);
      }
      if (page4Mesh) {
        page4Mesh.visible = pageNum >= 4;
        console.log(`- Fourth page ${pageNum >= 4 ? 'visible' : 'not visible'}`);
      }
      if (page5Mesh) {
        page5Mesh.visible = pageNum >= 5;
        console.log(`- Fifth page ${pageNum >= 5 ? 'visible' : 'not visible'}`);
      }
      if (page6Mesh) {
        page6Mesh.visible = pageNum >= 6;
        console.log(`- Sixth page ${pageNum >= 6 ? 'visible' : 'not visible'}`);
      }

      // Confirm current target page object
      let currentTargetMesh = targetMesh;

      // Ensure correct target page object
      switch (pageNum) {
        case 1: currentTargetMesh = pageMesh; break;
        case 2: currentTargetMesh = page2Mesh; break;
        case 3: currentTargetMesh = page3Mesh; break;
        case 4: currentTargetMesh = page4Mesh; break;
        case 5: currentTargetMesh = page5Mesh; break;
        case 6: currentTargetMesh = page6Mesh; break;
      }

      if (!currentTargetMesh) {
        console.error("Cannot find target page object, reset failed:", pageNum);
        isAnimating = false;
        return;
      }

      // Collect all currently visible pages
      const visiblePages = [];
      if (coverMesh && coverMesh.visible) visiblePages.push(coverMesh);
      if (pageMesh && pageMesh.visible) visiblePages.push(pageMesh);
      if (page2Mesh && page2Mesh.visible) visiblePages.push(page2Mesh);
      if (page3Mesh && page3Mesh.visible) visiblePages.push(page3Mesh);
      if (page4Mesh && page4Mesh.visible) visiblePages.push(page4Mesh);
      if (page5Mesh && page5Mesh.visible) visiblePages.push(page5Mesh);
      if (page6Mesh && page6Mesh.visible) visiblePages.push(page6Mesh);
      console.log("Number of visible pages:", visiblePages.length);

      // Save original state of current target page
      if (currentTargetMesh) {
        saveOriginalTransform(currentTargetMesh);
      }

      // Set position of all non-current pages to the left and shrink them
      visiblePages.forEach(page => {
        if (page !== currentTargetMesh) {
          console.log("Setting non-target page position:", page.userData.type);
          gsap.to(page.position, {
            x: -7, // Move to left
            y: 0,
            z: -2, // Move backward
            duration: 1,
            ease: "power2.inOut"
          });

          gsap.to(page.scale, {
            x: 0.9,
            y: 0.9,
            z: 0.9,
            duration: 1,
            ease: "power2.inOut"
          });

          gsap.to(page.rotation, {
            y: -0.2, // Slight rotation
            duration: 1,
            ease: "power2.inOut"
          });
        }
      });

      // Center target page
      console.log("Setting target page position:", currentTargetMesh.userData.type);
      gsap.to(currentTargetMesh.position, {
        x: coverPos.x, // Center position
        y: coverPos.y,
        z: coverPos.z,
        duration: 1,
        ease: "power2.inOut"
      });

      gsap.to(currentTargetMesh.scale, {
        x: coverScale.x,
        y: coverScale.y,
        z: coverScale.z,
        duration: 1,
        ease: "power2.inOut"
      });

      gsap.to(currentTargetMesh.rotation, {
        y: 0, // Face front
        duration: 1,
        ease: "power2.inOut"
      });

      // Ensure target page is on top
      console.log("Moving target page to top layer:", currentTargetMesh.userData.type);
      bookContainer.remove(currentTargetMesh);
      bookContainer.add(currentTargetMesh);

      // Play current page video
      console.log("Playing current page video:", pageNum);
      switch (pageNum) {
        case 1:
          if (page1VideoElement) {
            page1VideoElement.currentTime = 0;
            page1VideoElement.play().catch(e => console.error('Unable to play page1 video:', e));
            
            // 播放page1音頻
            const page1Audio = document.getElementById('page1Audio');
            if (page1Audio) {
              page1Audio.currentTime = 0;
              page1Audio.play().catch(e => console.error('無法播放page1音頻:', e));
            }
          }
          break;
        case 2:
          if (page2VideoElement) {
            page2VideoElement.currentTime = 0;
            page2VideoElement.play().catch(e => console.error('Unable to play page2 video:', e));
            
            // 播放page2音頻
            const page2Audio = document.getElementById('page2Audio');
            if (page2Audio) {
              page2Audio.currentTime = 0;
              page2Audio.play().catch(e => console.error('無法播放page2音頻:', e));
            }
          }
          break;
        case 3:
          if (page3VideoElement) {
            page3VideoElement.currentTime = 0;
            page3VideoElement.play().catch(e => console.error('Unable to play page3 video:', e));
            
            // 播放page3音頻
            const page3Audio = document.getElementById('page3Audio');
            if (page3Audio) {
              page3Audio.currentTime = 0;
              page3Audio.play().catch(e => console.error('無法播放page3音頻:', e));
            }
          }
          break;
        case 4:
          if (page4VideoElement) {
            page4VideoElement.currentTime = 0;
            page4VideoElement.play().catch(e => console.error('Unable to play page4 video:', e));
            
            // 播放page4音頻
            const page4Audio = document.getElementById('page4Audio');
            if (page4Audio) {
              page4Audio.currentTime = 0;
              page4Audio.play().catch(e => console.error('無法播放page4音頻:', e));
            }
          }
          break;
        case 5:
          if (page5VideoElement) {
            page5VideoElement.currentTime = 0;
            page5VideoElement.play().catch(e => console.error('Unable to play page5 video:', e));
            
            // 播放page5音頻
            const page5Audio = document.getElementById('page5Audio');
            if (page5Audio) {
              page5Audio.currentTime = 0;
              page5Audio.play().catch(e => console.error('無法播放page5音頻:', e));
            }
          }
          break;
        case 6:
          if (page6VideoElement) {
            page6VideoElement.currentTime = 0;
            page6VideoElement.play().catch(e => console.error('Unable to play page6 video:', e));
            
            // 播放page6音頻
            const page6Audio = document.getElementById('page6Audio');
            if (page6Audio) {
              page6Audio.currentTime = 0;
              page6Audio.play().catch(e => console.error('無法播放page6音頻:', e));
            }
          }
          break;
      }

      // Adjust camera position
      gsap.to(camera.position, {
        x: 0,
        y: 2,
        z: 12,
        duration: 1,
        ease: "power2.inOut",
        onComplete: function () {
          isAnimating = false;
          console.log("Page reset complete, current page:", pageNum);
          logPagePositions();
          
          // 更新页面可见性和游戏提示按钮状态
          updatePagesVisibility();
          
          console.log("===== PAGE RESET COMPLETE =====");
        }
      });
    }

    // Helper function to stop all videos
    function stopAllVideos() {
      // Check each video element, if playing then pause
      if (coverVideoElement && !coverVideoElement.paused) coverVideoElement.pause();
      if (page1VideoElement && !page1VideoElement.paused) page1VideoElement.pause();
      if (page2VideoElement && !page2VideoElement.paused) page2VideoElement.pause();
      if (page3VideoElement && !page3VideoElement.paused) page3VideoElement.pause();
      if (page4VideoElement && !page4VideoElement.paused) page4VideoElement.pause();
      if (page5VideoElement && !page5VideoElement.paused) page5VideoElement.pause();
      if (page6VideoElement && !page6VideoElement.paused) page6VideoElement.pause();
      
      // 停止所有音頻
      const coverAudio = document.getElementById('coverAudio');
      if (coverAudio) {
        coverAudio.pause();
        coverAudio.currentTime = 0;
      }
      
      const page1Audio = document.getElementById('page1Audio');
      if (page1Audio) {
        page1Audio.pause();
        page1Audio.currentTime = 0;
      }
      
      const page2Audio = document.getElementById('page2Audio');
      if (page2Audio) {
        page2Audio.pause();
        page2Audio.currentTime = 0;
      }
      
      const page3Audio = document.getElementById('page3Audio');
      if (page3Audio) {
        page3Audio.pause();
        page3Audio.currentTime = 0;
      }
      
      const page4Audio = document.getElementById('page4Audio');
      if (page4Audio) {
        page4Audio.pause();
        page4Audio.currentTime = 0;
      }
      
      const page5Audio = document.getElementById('page5Audio');
      if (page5Audio) {
        page5Audio.pause();
        page5Audio.currentTime = 0;
      }
      
      const page6Audio = document.getElementById('page6Audio');
      if (page6Audio) {
        page6Audio.pause();
        page6Audio.currentTime = 0;
      }
      
      // 恢复背景音乐音量
      if (bgMusicElement) {
        bgMusicElement.volume = 0.6; // 从0.8降低到0.6
      }
    }

    // Add a new function for transitioning from storybook to game page
    function transitionToGamePage() {
      if (isAnimating) return;
      isAnimating = true;

      console.log("Starting game page transition animation");

      // Enlarge the last page
      if (page6Mesh) {
        gsap.to(page6Mesh.scale, {
          x: 1.5,
          y: 1.5,
          z: 1.5,
          duration: 0.8,
          ease: "power2.inOut"
        });

        // Move the page forward to give the user a sense of "entering" the game
        gsap.to(page6Mesh.position, {
          z: 4,
          duration: 1,
          ease: "power2.inOut"
        });
      }

      // Create fade-out effect
      const overlay = document.createElement('div');
      overlay.style.position = 'absolute';
      overlay.style.top = '0';
      overlay.style.left = '0';
      overlay.style.width = '100%';
      overlay.style.height = '100%';
      overlay.style.backgroundColor = 'white';
      overlay.style.opacity = '0';
      overlay.style.transition = 'opacity 1s ease-in-out';
      overlay.style.zIndex = '1000';
      document.body.appendChild(overlay);

      // Fade out the scene
      setTimeout(() => {
        overlay.style.opacity = '1';
      }, 100);

      // Navigate to game page after transition completes
      setTimeout(() => {
        window.location.href = 'game.html';
      }, 1500);
    }

    // Add an indicator to prompt users to click the last page to enter the game
    function createGameNavigationPrompt() {
      // Remove existing prompt (if any)
      const existingPrompt = document.getElementById('gamePrompt');
      if (existingPrompt) {
        document.body.removeChild(existingPrompt);
      }

      // 只在当前页面是第6页时创建按钮
      if (currentPage !== 6) {
        return;
      }

      // Create prompt element
      const promptElement = document.createElement('div');
      promptElement.id = 'gamePrompt';
      promptElement.style.position = 'absolute';
      promptElement.style.bottom = '120px';
      promptElement.style.left = '50%';
      promptElement.style.transform = 'translateX(-50%)';
      promptElement.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
      promptElement.style.color = 'white';
      promptElement.style.padding = '12px 24px';
      promptElement.style.borderRadius = '30px';
      promptElement.style.fontFamily = '"Microsoft YaHei", "SimHei", Arial, sans-serif';
      promptElement.style.fontSize = '18px';
      promptElement.style.fontWeight = 'bold';
      promptElement.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.4)';
      promptElement.style.zIndex = '1000';
      promptElement.style.cursor = 'pointer';
      promptElement.style.animation = 'pulsePrompt 2s infinite';
      promptElement.innerHTML = 'Enter to Start Game <span style="margin-left: 8px;">➡️</span>';

      // Add animation style
      const style = document.createElement('style');
      style.textContent = `
        @keyframes pulsePrompt {
          0% { transform: translateX(-50%) scale(1); }
          50% { transform: translateX(-50%) scale(1.1); }
          100% { transform: translateX(-50%) scale(1); }
        }
      `;
      document.head.appendChild(style);

      // Add click event (clicking the prompt also navigates to the game page)
      promptElement.addEventListener('click', function () {
        transitionToGamePage();
      });

      // Add to page
      document.body.appendChild(promptElement);
    }
  </script>
</body>

</html>