<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Super Helpers: The Bee Savers | Interactive Storybook</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }

    #videoPreload,
    #videoPreload2 {
      position: absolute;
      top: -9999px;
      left: -9999px;
      width: 10px;
      height: 10px;
    }

    /* Skip button style */
    #skipButton {
      position: absolute;
      bottom: 30px;
      right: 30px;
      padding: 12px 25px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      border: 2px solid rgba(255, 255, 255, 0.8);
      border-radius: 25px;
      font-family: "Microsoft YaHei", "SimHei", Arial, sans-serif;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      z-index: 1000;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }

    #skipButton:hover {
      background-color: rgba(255, 255, 255, 0.9);
      color: #333;
      transform: scale(1.05);
    }
  </style>
</head>

<body>
  <!-- Skip button -->
  <button id="skipButton">Skip Story</button>

  <!-- Preload two videos but hide them -->
  <video id="videoPreload" preload="auto" muted playsinline>
    <source src="storytelling/BG-Image.mp4" type="video/mp4">
  </video>
  <video id="videoPreload2" preload="auto" muted playsinline>
    <source src="storytelling/BG-Image-2.mp4" type="video/mp4">
  </video>

  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.11.5/dist/gsap.min.js"></script>
  <script>
    let scene, camera, renderer;
    let coverMesh, pageMesh, page2Mesh, page3Mesh, page4Mesh, page5Mesh, page6Mesh;
    let coverVideoElement = null; // Cover video element
    let coverVideoTexture = null; // Cover video texture
    let page1VideoElement = null; // Page1 video element
    let page1VideoTexture = null; // Page1 video texture 
    let page2VideoElement = null; // Page2 video element
    let page2VideoTexture = null; // Page2 video texture
    let page3VideoElement = null; // Page3 video element
    let page3VideoTexture = null; // Page3 video texture
    let page4VideoElement = null; // Page4 video element
    let page4VideoTexture = null; // Page4 video texture
    let page5VideoElement = null; // Page5 video element
    let page5VideoTexture = null; // Page5 video texture
    let page6VideoElement = null; // Page6 video element
    let page6VideoTexture = null; // Page6 video texture
    let clock = new THREE.Clock();
    let camTargetZ = 12;
    let storyShown = false;
    let isAnimating = false;
    let bookContainer;
    let currentPage = 1;
    let focusedPage = null;
    let originalPositions = {};
    let originalScales = {};

    // Variables for alternating video playback
    let videoElement1, videoElement2;
    let activeVideoElement;
    let videoTexture1, videoTexture2;
    let activeVideoTexture;
    let videoBackground;
    let isVideo1Active = true;

    // Global variable for debugging
    let debugVideoTexture = null;

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);

      // Maintain moderate brightness settings to avoid color distortion
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.gammaFactor = 2.2;
      renderer.toneMappingExposure = 1.2;

      document.body.appendChild(renderer.domElement);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 2, 14); // Adjust camera distance to ensure enlarged book is fully visible

      // Maintain moderate lighting intensity to avoid over-saturated colors
      scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.5));
      const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
      dirLight.position.set(5, 10, 7.5);
      scene.add(dirLight);

      // Add moderate ambient light
      const ambientLight = new THREE.AmbientLight(0x606060, 0.8);
      scene.add(ambientLight);

      // Create book container, position in scene center
      bookContainer = new THREE.Group();
      bookContainer.position.set(0, 2, 0);
      scene.add(bookContainer);

      // Add video background support
      setupDualVideoBackground();

      // Only preload necessary videos
      preloadCoverVideo();
      preloadPage1Video();
      preloadPage2Video();
      preloadPage3Video();
      preloadPage4Video();
      preloadPage5Video();
      preloadPage6Video();

      // Set initial state: show cover
      currentPage = 0;

      // Set total number of pages to prevent accidental jumps to non-existent pages
      const totalPages = 7; // 0:Cover, 1:Page one, 2:Page two, 3:Page three, 4:Page four, 5:Page five, 6:Page six

      // Set camera observation position
      camTargetZ = 12;
      camera.position.z = 12;

      // Initial attempt to play videos
      setTimeout(function () {
        if (videoElement1) videoElement1.play().catch(e => console.error('Delayed start of video1 failed:', e));
        if (videoElement2) videoElement2.play().catch(e => console.error('Delayed start of video2 failed:', e));
        if (coverVideoElement) coverVideoElement.play().catch(e => console.error('Delayed start of cover video failed:', e));
      }, 1000);

      // Register window click event - handle user interaction
      window.addEventListener('click', (event) => {
        // Try to start all videos on user interaction (resolves autoplay restrictions in some browsers)
        startAllVideos();

        // If animation is in progress, ignore clicks
        if (isAnimating) {
          console.log("Animation in progress, ignoring click");
          return;
        }

        // Calculate mouse position and convert to normalized coordinates
        const mouse = new THREE.Vector2();
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;  // Range: -1 to 1
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; // Range: -1 to 1

        // Update the raycaster for detecting 3D object clicks
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, camera);

        // Collect all objects that might be clicked - only check visible pages
        const clickableObjects = [];
        if (coverMesh && coverMesh.visible) clickableObjects.push(coverMesh);
        if (pageMesh && pageMesh.visible) clickableObjects.push(pageMesh);
        if (page2Mesh && page2Mesh.visible) clickableObjects.push(page2Mesh);
        if (page3Mesh && page3Mesh.visible) clickableObjects.push(page3Mesh);
        if (page4Mesh && page4Mesh.visible) clickableObjects.push(page4Mesh);
        if (page5Mesh && page5Mesh.visible) clickableObjects.push(page5Mesh);
        if (page6Mesh && page6Mesh.visible) clickableObjects.push(page6Mesh);

        // Check if the ray intersects with any clickable objects
        const intersects = raycaster.intersectObjects(clickableObjects);

        // If an interactive object was clicked
        if (intersects.length > 0) {
          const clickedObject = intersects[0].object;

          console.log("Clicked object:", clickedObject.userData.type, "Current page:", currentPage);

          // Determine if the clicked object is the current centrally displayed page
          const isCurrentCenterObject = (
            (clickedObject === coverMesh && currentPage === 0) ||
            (clickedObject === pageMesh && currentPage === 1) ||
            (clickedObject === page2Mesh && currentPage === 2) ||
            (clickedObject === page3Mesh && currentPage === 3) ||
            (clickedObject === page4Mesh && currentPage === 4) ||
            (clickedObject === page5Mesh && currentPage === 5) ||
            (clickedObject === page6Mesh && currentPage === 6)
          );

          // If it's the current central page and no page is enlarged
          if (isCurrentCenterObject && !focusedPage) {
            // If current page is clicked, turn to next page
            if (clickedObject === coverMesh) {
              console.log("Clicked cover, turning to first page");
              slideCoverAnimation();
              return;
            } else if (clickedObject === pageMesh) {
              console.log("Clicked first page, turning to second page");
              turnToPage2Animation();
              return;
            } else if (clickedObject === page2Mesh) {
              console.log("Clicked second page, turning to third page");
              turnToPage3Animation();
              return;
            } else if (clickedObject === page3Mesh) {
              console.log("Clicked third page, turning to fourth page");
              turnToPage4Animation();
              return;
            } else if (clickedObject === page4Mesh) {
              console.log("Clicked fourth page, turning to fifth page");
              turnToPage5Animation();
              return;
            } else if (clickedObject === page5Mesh) {
              console.log("Clicked fifth page, turning to sixth page");
              turnToPage6Animation();
              return;
            } else if (clickedObject === page6Mesh) {
              console.log("Clicked sixth page, this is the last page");
              return;
            }
          }
          // If an enlarged page is clicked, restore original size
          else if (clickedObject === focusedPage) {
            console.log("Clicked enlarged page, restoring original size");
            resetAllPages();
            return;
          }
          // If a minimized page or side page is clicked
          else {
            console.log("Clicked non-central page:", clickedObject.userData.type);

            // Jump directly to the corresponding page based on clicked object
            if (clickedObject === coverMesh) {
              console.log("Clicked cover, jumping directly to cover");
              directResetToPage(0, coverMesh);
              return;
            } else if (clickedObject === pageMesh) {
              console.log("Clicked first page, jumping directly to first page");
              directResetToPage(1, pageMesh);
              return;
            } else if (clickedObject === page2Mesh) {
              console.log("Clicked second page, jumping directly to second page");
              directResetToPage(2, page2Mesh);
              return;
            } else if (clickedObject === page3Mesh) {
              console.log("Clicked third page, jumping directly to third page");
              directResetToPage(3, page3Mesh);
              return;
            } else if (clickedObject === page4Mesh) {
              console.log("Clicked fourth page, jumping directly to fourth page");
              directResetToPage(4, page4Mesh);
              return;
            } else if (clickedObject === page5Mesh) {
              console.log("Clicked fifth page, jumping directly to fifth page");
              directResetToPage(5, page5Mesh);
              return;
            } else if (clickedObject === page6Mesh) {
              console.log("Clicked sixth page, jumping directly to sixth page");
              directResetToPage(6, page6Mesh);
              return;
            }
          }
        }
        // Clicked empty area
        else if (focusedPage) {
          console.log("Clicked empty area, restoring all pages");
          resetAllPages();
        }
      });

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);

        // Also update background size if it's created
        if (videoBackground) {
          updateBackgroundSize(videoBackground);
        }
      });

      // Add Skip button click event
      document.getElementById('skipButton').addEventListener('click', function () {
        console.log("Clicked Skip button, redirecting to game page");
        window.location.href = 'game.html?fromStory=true';
      });
    }

    // Add Skip functionality - return to cover without animation
    function skipToMainCover() {
      // If animation is in progress, ignore click
      if (isAnimating) {
        console.log("Animation in progress, ignoring Skip request");
        return;
      }

      console.log("Executing Skip action, returning directly to cover");
      isAnimating = true;

      // Clear focus state
      focusedPage = null;

      // Stop all videos
      stopAllVideos();

      // Set state directly, without animation
      if (coverMesh) {
        // Ensure cover is visible
        coverMesh.visible = true;

        // Set cover position and size directly
        coverMesh.position.set(0, 0, 2);
        coverMesh.scale.set(1.3, 1.3, 1.3);
        coverMesh.rotation.set(0, 0, 0);

        // Ensure cover is on top
        bookContainer.remove(coverMesh);
        bookContainer.add(coverMesh);
      }

      // Hide all non-cover pages
      if (pageMesh) pageMesh.visible = false;
      if (page2Mesh) page2Mesh.visible = false;
      if (page3Mesh) page3Mesh.visible = false;
      if (page4Mesh) page4Mesh.visible = false;
      if (page5Mesh) page5Mesh.visible = false;
      if (page6Mesh) page6Mesh.visible = false;

      // Set current page to cover
      currentPage = 0;

      // Play cover video
      if (coverVideoElement) {
        coverVideoElement.currentTime = 0;
        coverVideoElement.play().catch(e => console.error('Unable to play cover video:', e));
      }

      // Reset camera position
      camera.position.set(0, 2, 12);

      // Complete operation
      isAnimating = false;
      console.log("Directly returned to cover state");
    }

    // Helper function to start all videos
    function startAllVideos() {
      if (videoElement1 && videoElement1.paused) {
        videoElement1.play().catch(e => console.error('Unable to play background video1:', e));
      }
      if (videoElement2 && videoElement2.paused) {
        videoElement2.play().catch(e => console.error('Unable to play background video2:', e));
      }
      if (coverVideoElement && coverVideoElement.paused) {
        coverVideoElement.play().catch(e => console.error('Unable to play cover video:', e));
      }
      if (page1VideoElement && page1VideoElement.paused) {
        page1VideoElement.play().catch(e => console.error('Unable to play page1 video:', e));
      }
      if (page2VideoElement && page2VideoElement.paused) {
        page2VideoElement.play().catch(e => console.error('Unable to play page2 video:', e));
      }
      if (page3VideoElement && page3VideoElement.paused) {
        page3VideoElement.play().catch(e => console.error('Unable to play page3 video:', e));
      }
      if (page4VideoElement && page4VideoElement.paused) {
        page4VideoElement.play().catch(e => console.error('Unable to play page4 video:', e));
      }
      if (page5VideoElement && page5VideoElement.paused) {
        page5VideoElement.play().catch(e => console.error('Unable to play page5 video:', e));
      }
      if (page6VideoElement && page6VideoElement.paused) {
        page6VideoElement.play().catch(e => console.error('Unable to play page6 video:', e));
      }
    }

    // Set dual video background
    function setupDualVideoBackground() {
      // Get two video elements
      videoElement1 = document.getElementById('videoPreload');
      videoElement2 = document.getElementById('videoPreload2');

      if (!videoElement1 || !videoElement2) {
        console.error('Unable to find video elements');
        fallbackToImage();
        return;
      }

      console.log('Found two video elements, setting alternating playback');

      // Set properties of both videos
      videoElement1.muted = true;
      videoElement1.playsInline = true;
      videoElement1.loop = false; // We won't loop manually, so no need to loop

      videoElement2.muted = true;
      videoElement2.playsInline = true;
      videoElement2.loop = false;

      // Activate first video
      activeVideoElement = videoElement1;
      isVideo1Active = true;

      // Create two video textures
      videoTexture1 = new THREE.VideoTexture(videoElement1);
      setupVideoTexture(videoTexture1);

      videoTexture2 = new THREE.VideoTexture(videoElement2);
      setupVideoTexture(videoTexture2);

      // Activate first texture
      activeVideoTexture = videoTexture1;
      debugVideoTexture = videoTexture1;

      // Ensure that the other video starts playing automatically when the first one ends
      videoElement1.addEventListener('timeupdate', function () {
        // Prepare to switch when video1 is about to end (last 0.5 seconds)
        if (videoElement1.currentTime > videoElement1.duration - 0.5 && isVideo1Active) {
          videoElement2.currentTime = 0;
          videoElement2.play().catch(e => console.error('Failed to preload video2:', e));
        }
      });

      videoElement1.addEventListener('ended', function () {
        console.log('Video1 finished, switching to video2');
        // Start video2 immediately (already preloaded)
        videoElement2.play().catch(e => console.error('Failed to switch to video2:', e));

        // Update active video reference
        activeVideoElement = videoElement2;
        activeVideoTexture = videoTexture2;
        debugVideoTexture = videoTexture2;
        isVideo1Active = false;

        // Update background texture
        if (videoBackground && videoBackground.material) {
          videoBackground.material.map = videoTexture2;
        }
      });

      videoElement2.addEventListener('timeupdate', function () {
        // Prepare to switch when video2 is about to end (last 0.5 seconds)
        if (videoElement2.currentTime > videoElement2.duration - 0.5 && !isVideo1Active) {
          videoElement1.currentTime = 0;
          videoElement1.play().catch(e => console.error('Failed to preload video1:', e));
        }
      });

      videoElement2.addEventListener('ended', function () {
        console.log('Video2 finished, switching to video1');
        // Start video1 immediately (already preloaded)
        videoElement1.play().catch(e => console.error('Failed to switch to video1:', e));

        // Update active video reference
        activeVideoElement = videoElement1;
        activeVideoTexture = videoTexture1;
        debugVideoTexture = videoTexture1;
        isVideo1Active = true;

        // Update background texture
        if (videoBackground && videoBackground.material) {
          videoBackground.material.map = videoTexture1;
        }
      });

      // Start trying to play the first video
      videoElement1.play().then(() => {
        console.log('Video1 started playing');
        // Create background
        createBackgroundWithTexture(videoTexture1);
      }).catch(error => {
        console.error('Failed to play initial video:', error);
        fallbackToImage();
      });
    }

    // Set common properties for video textures
    function setupVideoTexture(texture) {
      texture.wrapS = THREE.ClampToEdgeWrapping;
      texture.wrapT = THREE.ClampToEdgeWrapping;
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.center.set(0.5, 0.5);
      texture.repeat.set(1, 1);
      texture.encoding = THREE.sRGBEncoding;
    }

    function fallbackToImage() {
      // Fallback to static image
      console.log('Using static image as background');
      const loader = new THREE.TextureLoader();
      loader.load('storytelling/forest_background.jpg', function (texture) {
        createBackgroundWithTexture(texture);
      });
    }

    // Update background size based on window size
    function updateBackgroundSize(background) {
      const aspectRatio = window.innerWidth / window.innerHeight;
      let newWidth, newHeight;

      if (aspectRatio > 16 / 9) {
        // Wide screen device, prioritize width
        newWidth = 60 * aspectRatio / (16 / 9); // Reduce from 80 to 60
        newHeight = 60 * (9 / 16);
      } else {
        // Tall screen device, prioritize height
        newWidth = 60; // Reduce from 80 to 60
        newHeight = 60 / aspectRatio * (16 / 9);
      }

      background.geometry = new THREE.PlaneGeometry(newWidth, newHeight);
      console.log(`Screen adjustment: ${aspectRatio.toFixed(2)}, New background size: ${newWidth.toFixed(2)}x${newHeight.toFixed(2)}`);
    }

    // Create background using given texture
    function createBackgroundWithTexture(texture) {
      console.log('Creating background, using texture:', texture);

      // Calculate background size to make it smaller
      const aspectRatio = window.innerWidth / window.innerHeight;
      let bgWidth, bgHeight;

      if (aspectRatio > 16 / 9) {
        // Wide screen device, prioritize width
        bgWidth = 60 * aspectRatio / (16 / 9); // Reduce from 80 to 60
        bgHeight = 60 * (9 / 16);
      } else {
        // Tall screen device, prioritize height
        bgWidth = 60; // Reduce from 80 to 60
        bgHeight = 60 / aspectRatio * (16 / 9);
      }

      console.log(`Screen aspect ratio: ${aspectRatio.toFixed(2)}, Background size: ${bgWidth.toFixed(2)}x${bgHeight.toFixed(2)}`);

      const bgGeometry = new THREE.PlaneGeometry(bgWidth, bgHeight);
      const bgMaterial = new THREE.MeshBasicMaterial({
        map: texture,
        side: THREE.DoubleSide,
      });

      // Main background panel - adjust position and size
      videoBackground = new THREE.Mesh(bgGeometry, bgMaterial);
      videoBackground.position.set(0, 0, -18); // Slightly closer, adjusted from -20 to -18
      bookContainer.add(videoBackground);

      // Add particle effect
      addParticles(bookContainer);

      // Reduce fog to make video clearer
      scene.fog = new THREE.FogExp2(0xaaccff, 0.0005);

      // Adjust camera position for better background observation
      camera.position.z = 12;
      camTargetZ = 10;
    }

    // Modify particle effect to not block video
    function addParticles(parent) {
      const particlesGeometry = new THREE.BufferGeometry();
      const particleCount = 300; // Reduce particle count

      const positionArray = new Float32Array(particleCount * 3);
      const sizeArray = new Float32Array(particleCount);

      for (let i = 0; i < particleCount; i++) {
        // Randomly distributed around the field of view, not concentrated in the center
        const radius = 12 + Math.random() * 18; // Increase range of particle distribution
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI / 2; // Hemisphere distribution

        // Distributed around the area, not blocking the center of the video
        positionArray[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
        positionArray[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
        positionArray[i * 3 + 2] = -radius * Math.cos(phi) - 2; // Bias towards the back

        sizeArray[i] = 0.05 + Math.random() * 0.15; // Increase particle size
      }

      particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positionArray, 3));
      particlesGeometry.setAttribute('size', new THREE.BufferAttribute(sizeArray, 1));

      const particlesMaterial = new THREE.PointsMaterial({
        color: 0xffffff, // Use pure white, enhance brightness
        size: 0.15, // Increase size
        transparent: true,
        opacity: 0.7, // Increase opacity, improve visibility
        sizeAttenuation: true
      });

      const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
      parent.add(particleSystem);

      // Add slow rotation animation
      gsap.to(particleSystem.rotation, {
        y: Math.PI * 2,
        duration: 180, // Slower rotation
        repeat: -1,
        ease: "none"
      });
    }

    // Preload page1 video
    function preloadPage1Video() {
      // Create hidden video element
      page1VideoElement = document.createElement('video');
      page1VideoElement.id = 'page1Video';
      page1VideoElement.style.display = 'none';
      page1VideoElement.muted = true;
      page1VideoElement.playsInline = true;
      page1VideoElement.loop = true; // Loop playback
      page1VideoElement.crossOrigin = 'anonymous';
      page1VideoElement.preload = 'auto';

      // Add video source
      const source = document.createElement('source');
      source.src = 'storytelling/page1.mp4';
      source.type = 'video/mp4';
      page1VideoElement.appendChild(source);

      // Add to DOM
      document.body.appendChild(page1VideoElement);

      // Load video
      page1VideoElement.load();

      // Add load success event
      page1VideoElement.addEventListener('canplaythrough', function onCanPlay() {
        console.log('Page1 video loaded, ready to play');

        // Create video texture (but don't play yet)
        if (!page1VideoTexture) {
          page1VideoTexture = new THREE.VideoTexture(page1VideoElement);
          page1VideoTexture.minFilter = THREE.LinearFilter;
          page1VideoTexture.magFilter = THREE.LinearFilter;
          page1VideoTexture.format = THREE.RGBAFormat;
          page1VideoTexture.encoding = THREE.sRGBEncoding;
          page1VideoTexture.generateMipmaps = false;
        }

        // Remove event listener to avoid duplicate calls
        page1VideoElement.removeEventListener('canplaythrough', onCanPlay);
      });

      // Add error handling
      page1VideoElement.addEventListener('error', function (e) {
        console.error('Failed to load Page1 video:', e);
        // Load static image as fallback
        const loader = new THREE.TextureLoader();
        loader.load('storytelling/page1.jpg', function (texture) {
          page1VideoTexture = texture;
        });
      });

      console.log('Page1 video preloading started');
    }

    // Preload page2 video
    function preloadPage2Video() {
      // Create hidden video element
      page2VideoElement = document.createElement('video');
      page2VideoElement.id = 'page2Video';
      page2VideoElement.style.display = 'none';
      page2VideoElement.muted = true;
      page2VideoElement.playsInline = true;
      page2VideoElement.loop = true; // Allow video to loop playback
      page2VideoElement.crossOrigin = 'anonymous';
      page2VideoElement.preload = 'auto'; // Ensure preloading

      // Add video source
      const source = document.createElement('source');
      source.src = 'storytelling/page2.mp4';
      source.type = 'video/mp4';
      page2VideoElement.appendChild(source);

      // Add to DOM
      document.body.appendChild(page2VideoElement);

      // Load video
      page2VideoElement.load();

      // When video has loaded enough data
      page2VideoElement.addEventListener('canplaythrough', function onCanPlay() {
        console.log('Page2 video ready to play');

        // Create video texture (but don't play yet)
        if (!page2VideoTexture) {
          page2VideoTexture = new THREE.VideoTexture(page2VideoElement);
          page2VideoTexture.minFilter = THREE.LinearFilter;
          page2VideoTexture.magFilter = THREE.LinearFilter;
          page2VideoTexture.format = THREE.RGBAFormat;
          page2VideoTexture.encoding = THREE.sRGBEncoding;
          page2VideoTexture.generateMipmaps = false;
        }

        // Remove event listener to avoid duplicate calls
        page2VideoElement.removeEventListener('canplaythrough', onCanPlay);
      });

      // Add error handling
      page2VideoElement.addEventListener('error', function (e) {
        console.error('Failed to load Page2 video:', e);
        // Load static image as fallback
        const loader = new THREE.TextureLoader();
        loader.load('storytelling/page2.jpg', function (texture) {
          page2VideoTexture = texture;
        });
      });

      console.log('Page2 video preloading started');
    }

    // Preload page3 video
    function preloadPage3Video() {
      // Create hidden video element
      page3VideoElement = document.createElement('video');
      page3VideoElement.id = 'page3Video';
      page3VideoElement.style.display = 'none';
      page3VideoElement.muted = true;
      page3VideoElement.playsInline = true;
      page3VideoElement.loop = true; // Allow video to loop playback
      page3VideoElement.crossOrigin = 'anonymous';
      page3VideoElement.preload = 'auto'; // Ensure preloading

      // Add video source
      const source = document.createElement('source');
      source.src = 'storytelling/page3.mp4';
      source.type = 'video/mp4';
      page3VideoElement.appendChild(source);

      // Add to DOM
      document.body.appendChild(page3VideoElement);

      // Load video
      page3VideoElement.load();

      // When video has loaded enough data
      page3VideoElement.addEventListener('canplaythrough', function onCanPlay() {
        console.log('Page3 video ready to play');

        // Create video texture (but don't play yet)
        if (!page3VideoTexture) {
          page3VideoTexture = new THREE.VideoTexture(page3VideoElement);
          page3VideoTexture.minFilter = THREE.LinearFilter;
          page3VideoTexture.magFilter = THREE.LinearFilter;
          page3VideoTexture.format = THREE.RGBAFormat;
          page3VideoTexture.encoding = THREE.sRGBEncoding;
          page3VideoTexture.generateMipmaps = false;
        }

        // Remove event listener to avoid duplicate calls
        page3VideoElement.removeEventListener('canplaythrough', onCanPlay);
      });

      // Add error handling
      page3VideoElement.addEventListener('error', function (e) {
        console.error('Failed to load Page3 video:', e);
        // Load static image as fallback
        const loader = new THREE.TextureLoader();
        loader.load('storytelling/page3.jpg', function (texture) {
          page3VideoTexture = texture;
        });
      });

      console.log('Page3 video preloading started');
    }

    // Preload page4 video
    function preloadPage4Video() {
      // Create hidden video element
      page4VideoElement = document.createElement('video');
      page4VideoElement.id = 'page4Video';
      page4VideoElement.style.display = 'none';
      page4VideoElement.muted = true;
      page4VideoElement.playsInline = true;
      page4VideoElement.loop = true; // Allow video to loop playback
      page4VideoElement.crossOrigin = 'anonymous';
      page4VideoElement.preload = 'auto'; // Ensure preloading

      // Add video source
      const source = document.createElement('source');
      source.src = 'storytelling/page4.mp4';
      source.type = 'video/mp4';
      page4VideoElement.appendChild(source);

      // Add to DOM
      document.body.appendChild(page4VideoElement);

      // Load video
      page4VideoElement.load();

      // When video has loaded enough data
      page4VideoElement.addEventListener('canplaythrough', function onCanPlay() {
        console.log('Page4 video ready to play');

        // Create video texture (but don't play yet)
        if (!page4VideoTexture) {
          page4VideoTexture = new THREE.VideoTexture(page4VideoElement);
          page4VideoTexture.minFilter = THREE.LinearFilter;
          page4VideoTexture.magFilter = THREE.LinearFilter;
          page4VideoTexture.format = THREE.RGBAFormat;
          page4VideoTexture.encoding = THREE.sRGBEncoding;
          page4VideoTexture.generateMipmaps = false;
        }

        // Remove event listener to avoid duplicate calls
        page4VideoElement.removeEventListener('canplaythrough', onCanPlay);
      });

      // Add error handling
      page4VideoElement.addEventListener('error', function (e) {
        console.error('Failed to load Page4 video:', e);
        // Load static image as fallback
        const loader = new THREE.TextureLoader();
        loader.load('storytelling/page4.jpg', function (texture) {
          page4VideoTexture = texture;
        });
      });

      console.log('Page4 video preloading started');
    }

    // Preload page5 video
    function preloadPage5Video() {
      // Create hidden video element
      page5VideoElement = document.createElement('video');
      page5VideoElement.id = 'page5Video';
      page5VideoElement.style.display = 'none';
      page5VideoElement.muted = true;
      page5VideoElement.playsInline = true;
      page5VideoElement.loop = true; // Allow video to loop playback
      page5VideoElement.crossOrigin = 'anonymous';
      page5VideoElement.preload = 'auto'; // Ensure preloading

      // Add video source
      const source = document.createElement('source');
      source.src = 'storytelling/page5.mp4';
      source.type = 'video/mp4';
      page5VideoElement.appendChild(source);

      // Add to DOM
      document.body.appendChild(page5VideoElement);

      // Load video
      page5VideoElement.load();

      // When video has loaded enough data
      page5VideoElement.addEventListener('canplaythrough', function onCanPlay() {
        console.log('Page5 video ready to play');

        // Create video texture (but don't play yet)
        if (!page5VideoTexture) {
          page5VideoTexture = new THREE.VideoTexture(page5VideoElement);
          page5VideoTexture.minFilter = THREE.LinearFilter;
          page5VideoTexture.magFilter = THREE.LinearFilter;
          page5VideoTexture.format = THREE.RGBAFormat;
          page5VideoTexture.encoding = THREE.sRGBEncoding;
          page5VideoTexture.generateMipmaps = false;
        }

        // Remove event listener to avoid duplicate calls
        page5VideoElement.removeEventListener('canplaythrough', onCanPlay);
      });

      // Add error handling
      page5VideoElement.addEventListener('error', function (e) {
        console.error('Failed to load Page5 video:', e);
        // Load static image as fallback
        const loader = new THREE.TextureLoader();
        loader.load('storytelling/page5.jpg', function (texture) {
          page5VideoTexture = texture;
        });
      });

      console.log('Page5 video preloading started');
    }

    // Preload page6 video
    function preloadPage6Video() {
      // Create hidden video element
      page6VideoElement = document.createElement('video');
      page6VideoElement.id = 'page6Video';
      page6VideoElement.style.display = 'none';
      page6VideoElement.muted = true;
      page6VideoElement.playsInline = true;
      page6VideoElement.loop = true; // Allow video to loop playback
      page6VideoElement.crossOrigin = 'anonymous';
      page6VideoElement.preload = 'auto'; // Ensure preloading

      // Add video source
      const source = document.createElement('source');
      source.src = 'storytelling/page6.mp4';
      source.type = 'video/mp4';
      page6VideoElement.appendChild(source);

      // Add to DOM
      document.body.appendChild(page6VideoElement);

      // Load video
      page6VideoElement.load();

      // When video has loaded enough data
      page6VideoElement.addEventListener('canplaythrough', function onCanPlay() {
        console.log('Page6 video ready to play');

        // Create video texture (but don't play yet)
        if (!page6VideoTexture) {
          page6VideoTexture = new THREE.VideoTexture(page6VideoElement);
          page6VideoTexture.minFilter = THREE.LinearFilter;
          page6VideoTexture.magFilter = THREE.LinearFilter;
          page6VideoTexture.format = THREE.RGBAFormat;
          page6VideoTexture.encoding = THREE.sRGBEncoding;
          page6VideoTexture.generateMipmaps = false;
        }

        // Remove event listener to avoid duplicate calls
        page6VideoElement.removeEventListener('canplaythrough', onCanPlay);
      });

      // Add error handling
      page6VideoElement.addEventListener('error', function (e) {
        console.error('Failed to load Page6 video:', e);
        // Load static image as fallback
        const loader = new THREE.TextureLoader();
        loader.load('storytelling/page6.jpg', function (texture) {
          page6VideoTexture = texture;
        });
      });

      console.log('Page6 video preloading started');
    }

    // Preload cover video
    function preloadCoverVideo() {
      // Create hidden video element
      coverVideoElement = document.createElement('video');
      coverVideoElement.id = 'coverVideo';
      coverVideoElement.style.display = 'none';
      coverVideoElement.muted = true;
      coverVideoElement.playsInline = true;
      coverVideoElement.loop = true; // Loop playback
      coverVideoElement.crossOrigin = 'anonymous';
      coverVideoElement.preload = 'auto';

      // Add video source
      const source = document.createElement('source');
      source.src = 'storytelling/cover.mp4';
      source.type = 'video/mp4';
      coverVideoElement.appendChild(source);

      // Add to DOM
      document.body.appendChild(coverVideoElement);

      // Load video
      coverVideoElement.load();

      // Add load success event
      coverVideoElement.addEventListener('canplaythrough', function onCanPlay() {
        console.log('Cover video loaded, ready to play');

        // Create video texture
        if (!coverVideoTexture) {
          coverVideoTexture = new THREE.VideoTexture(coverVideoElement);
          coverVideoTexture.minFilter = THREE.LinearFilter;
          coverVideoTexture.magFilter = THREE.LinearFilter;
          coverVideoTexture.format = THREE.RGBAFormat;
          coverVideoTexture.encoding = THREE.sRGBEncoding;
          coverVideoTexture.generateMipmaps = false;

          // Create cover mesh
          const height = 5.5;
          const width = height * (2035 / 2044);

          const material = new THREE.MeshBasicMaterial({
            map: coverVideoTexture,
            side: THREE.DoubleSide,
            transparent: true,
          });

          const geometry = new THREE.PlaneGeometry(width, height);
          coverMesh = new THREE.Mesh(geometry, material);
          coverMesh.position.set(0, 0, 2); // Place cover in front center position
          coverMesh.scale.set(1.3, 1.3, 1.3); // Initial cover slightly enlarged
          coverMesh.userData = { type: 'cover' };
          bookContainer.add(coverMesh);

          // Save original position and scale of cover for reference by subsequent pages
          window.coverOriginalPosition = { x: 0, y: 0, z: 2 };
          window.coverOriginalScale = { x: 1.3, y: 1.3, z: 1.3 };

          // Save original transform of cover
          saveOriginalTransform(coverMesh);

          coverVideoElement.play().catch(e => {
            console.error('Unable to play cover video:', e);
          });

          console.log('Cover video mesh created');
        }

        // Remove event listener to avoid duplicate calls
        coverVideoElement.removeEventListener('canplaythrough', onCanPlay);
      });

      // Add error handling
      coverVideoElement.addEventListener('error', function (e) {
        console.error('Cover video loading failed:', e);
        // Load static image as fallback
        const loader = new THREE.TextureLoader();
        loader.load('storytelling/cover.jpg', function (texture) {
          coverVideoTexture = texture;

          // Create cover mesh
          const height = 5.5;
          const width = height * (2035 / 2044);

          const material = new THREE.MeshBasicMaterial({
            map: coverVideoTexture,
            side: THREE.DoubleSide,
            transparent: true,
          });

          const geometry = new THREE.PlaneGeometry(width, height);
          coverMesh = new THREE.Mesh(geometry, material);
          coverMesh.position.set(0, 0, 2); // Place cover in front center position
          coverMesh.scale.set(1.3, 1.3, 1.3); // Initial cover slightly enlarged
          coverMesh.userData = { type: 'cover' };
          bookContainer.add(coverMesh);

          // Save original position and scale of cover for reference by subsequent pages
          window.coverOriginalPosition = { x: 0, y: 0, z: 2 };
          window.coverOriginalScale = { x: 1.3, y: 1.3, z: 1.3 };

          // Save original transform of cover
          saveOriginalTransform(coverMesh);

          console.log('Cover image mesh created');
        });
      });

      console.log('Cover video preloading started');
    }

    // Modify cover slide animation, implement cover shrinking and moving left, page1 enlarging and showing
    function slideCoverAnimation() {
      console.log("Starting cover slide animation");
      isAnimating = true;

      // Reset focus state
      focusedPage = null;

      // Get initial display position and size of cover
      const coverPos = window.coverOriginalPosition;
      const coverScale = window.coverOriginalScale;

      // If pageMesh already exists, remove it first
      if (pageMesh) {
        bookContainer.remove(pageMesh);
        pageMesh = null;
      }

      // Create page1 video plane
      const height = 5.5;
      const width = height * (2035 / 2044);

      const material = new THREE.MeshBasicMaterial({
        map: page1VideoTexture,
        side: THREE.DoubleSide,
        transparent: true,
        toneMapped: false
      });

      const geometry = new THREE.PlaneGeometry(width, height);
      pageMesh = new THREE.Mesh(geometry, material);

      // Initial position set to right side for right-to-left page turning
      pageMesh.position.set(7, 0, -1);
      pageMesh.scale.set(1, 1, 1);
      pageMesh.rotation.y = 0.2; // Initial slight rotation
      pageMesh.userData = { type: 'page1' };
      pageMesh.visible = true;
      bookContainer.add(pageMesh);

      // Start playing page1 video
      if (page1VideoElement) {
        page1VideoElement.currentTime = 0;
        page1VideoElement.play().catch(err => {
          console.error('Unable to play page1 video:', err);
        });
      }

      // Create a spine object, fixed on the left
      const spineGeometry = new THREE.BoxGeometry(0.2, height, 0.3);
      const spineMaterial = new THREE.MeshBasicMaterial({ color: 0x555555 });
      const spine = new THREE.Mesh(spineGeometry, spineMaterial);
      spine.position.set(-width / 2 - 0.1, 0, 0); // Fixed at left edge
      pageMesh.add(spine);

      // Cover leftward rotation animation (around spine)
      gsap.to(coverMesh.position, {
        x: -7, // Move to left position
        y: 0,
        z: -2, // Move backward
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Cover shrink leftward
      gsap.to(coverMesh.scale, {
        x: 0.9,
        y: 0.9,
        z: 0.9,
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Add cover rotation effect
      gsap.to(coverMesh.rotation, {
        y: -0.2, // Slight left rotation
        duration: 1.2,
        ease: "power2.inOut"
      });

      // First page right-to-left turning animation
      gsap.to(pageMesh.position, {
        x: coverPos.x, // Move to center position
        y: coverPos.y,
        z: coverPos.z,
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2 // Slight delay
      });

      // First page scales to original cover size
      gsap.to(pageMesh.scale, {
        x: coverScale.x,
        y: coverScale.y,
        z: coverScale.z,
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2
      });

      // First page rotates to face front
      gsap.to(pageMesh.rotation, {
        y: 0, // Rotate back to front
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2,
        onComplete: function () {
          storyShown = true;
          isAnimating = false;
          currentPage = 1;

          // Set each page to correct visibility
          if (coverMesh) coverMesh.visible = true;
          if (pageMesh) pageMesh.visible = true;
          if (page2Mesh) page2Mesh.visible = false;

          // Save original transform of first page
          saveOriginalTransform(pageMesh);

          // To maintain layer relationship, ensure page1 is on top
          bookContainer.remove(pageMesh);
          bookContainer.add(pageMesh);

          console.log("Cover slide animation complete, current page:", currentPage);
        }
      });

      // Simultaneously move camera slightly to better observe the entire scene
      gsap.to(camera.position, {
        x: 0,
        y: 2,
        z: 12,
        duration: 1.5,
        ease: "power1.inOut"
      });
    }

    // Add Skip functionality - return to cover without animation
    function skipToMainCover() {
      // If animation is in progress, ignore click
      if (isAnimating) {
        console.log("Animation in progress, ignoring Skip request");
        return;
      }

      console.log("Executing Skip action, returning directly to cover");
      isAnimating = true;

      // Clear focus state
      focusedPage = null;

      // Stop all videos
      stopAllVideos();

      // Set state directly, without animation
      if (coverMesh) {
        // Ensure cover is visible
        coverMesh.visible = true;

        // Set cover position and size directly
        coverMesh.position.set(0, 0, 2);
        coverMesh.scale.set(1.3, 1.3, 1.3);
        coverMesh.rotation.set(0, 0, 0);

        // Ensure cover is on top
        bookContainer.remove(coverMesh);
        bookContainer.add(coverMesh);
      }

      // Hide all non-cover pages
      if (pageMesh) pageMesh.visible = false;
      if (page2Mesh) page2Mesh.visible = false;
      if (page3Mesh) page3Mesh.visible = false;
      if (page4Mesh) page4Mesh.visible = false;
      if (page5Mesh) page5Mesh.visible = false;
      if (page6Mesh) page6Mesh.visible = false;

      // Set current page to cover
      currentPage = 0;

      // Play cover video
      if (coverVideoElement) {
        coverVideoElement.currentTime = 0;
        coverVideoElement.play().catch(e => console.error('Unable to play cover video:', e));
      }

      // Reset camera position
      camera.position.set(0, 2, 12);

      // Complete operation
      isAnimating = false;
      console.log("Directly returned to cover state");
    }

    // Helper function to start all videos
    function startAllVideos() {
      if (videoElement1 && videoElement1.paused) {
        videoElement1.play().catch(e => console.error('Unable to play background video1:', e));
      }
      if (videoElement2 && videoElement2.paused) {
        videoElement2.play().catch(e => console.error('Unable to play background video2:', e));
      }
      if (coverVideoElement && coverVideoElement.paused) {
        coverVideoElement.play().catch(e => console.error('Unable to play cover video:', e));
      }
      if (page1VideoElement && page1VideoElement.paused) {
        page1VideoElement.play().catch(e => console.error('Unable to play page1 video:', e));
      }
      if (page2VideoElement && page2VideoElement.paused) {
        page2VideoElement.play().catch(e => console.error('Unable to play page2 video:', e));
      }
      if (page3VideoElement && page3VideoElement.paused) {
        page3VideoElement.play().catch(e => console.error('Unable to play page3 video:', e));
      }
      if (page4VideoElement && page4VideoElement.paused) {
        page4VideoElement.play().catch(e => console.error('Unable to play page4 video:', e));
      }
      if (page5VideoElement && page5VideoElement.paused) {
        page5VideoElement.play().catch(e => console.error('Unable to play page5 video:', e));
      }
      if (page6VideoElement && page6VideoElement.paused) {
        page6VideoElement.play().catch(e => console.error('Unable to play page6 video:', e));
      }
    }

    // Set dual video background
    function setupDualVideoBackground() {
      // Get two video elements
      videoElement1 = document.getElementById('videoPreload');
      videoElement2 = document.getElementById('videoPreload2');

      if (!videoElement1 || !videoElement2) {
        console.error('Unable to find video elements');
        fallbackToImage();
        return;
      }

      console.log('Found two video elements, setting alternating playback');

      // Set properties of both videos
      videoElement1.muted = true;
      videoElement1.playsInline = true;
      videoElement1.loop = false; // We won't loop manually, so no need to loop

      videoElement2.muted = true;
      videoElement2.playsInline = true;
      videoElement2.loop = false;

      // Activate first video
      activeVideoElement = videoElement1;
      isVideo1Active = true;

      // Create two video textures
      videoTexture1 = new THREE.VideoTexture(videoElement1);
      setupVideoTexture(videoTexture1);

      videoTexture2 = new THREE.VideoTexture(videoElement2);
      setupVideoTexture(videoTexture2);

      // Activate first texture
      activeVideoTexture = videoTexture1;
      debugVideoTexture = videoTexture1;

      // Ensure that the other video starts playing automatically when the first one ends
      videoElement1.addEventListener('timeupdate', function () {
        // Prepare to switch when video1 is about to end (last 0.5 seconds)
        if (videoElement1.currentTime > videoElement1.duration - 0.5 && isVideo1Active) {
          videoElement2.currentTime = 0;
          videoElement2.play().catch(e => console.error('Failed to preload video2:', e));
        }
      });

      videoElement1.addEventListener('ended', function () {
        console.log('Video1 finished, switching to video2');
        // Start video2 immediately (already preloaded)
        videoElement2.play().catch(e => console.error('Failed to switch to video2:', e));

        // Update active video reference
        activeVideoElement = videoElement2;
        activeVideoTexture = videoTexture2;
        debugVideoTexture = videoTexture2;
        isVideo1Active = false;

        // Update background texture
        if (videoBackground && videoBackground.material) {
          videoBackground.material.map = videoTexture2;
        }
      });

      videoElement2.addEventListener('timeupdate', function () {
        // Prepare to switch when video2 is about to end (last 0.5 seconds)
        if (videoElement2.currentTime > videoElement2.duration - 0.5 && !isVideo1Active) {
          videoElement1.currentTime = 0;
          videoElement1.play().catch(e => console.error('Failed to preload video1:', e));
        }
      });

      videoElement2.addEventListener('ended', function () {
        console.log('Video2 finished, switching to video1');
        // Start video1 immediately (already preloaded)
        videoElement1.play().catch(e => console.error('Failed to switch to video1:', e));

        // Update active video reference
        activeVideoElement = videoElement1;
        activeVideoTexture = videoTexture1;
        debugVideoTexture = videoTexture1;
        isVideo1Active = true;

        // Update background texture
        if (videoBackground && videoBackground.material) {
          videoBackground.material.map = videoTexture1;
        }
      });

      // Start trying to play the first video
      videoElement1.play().then(() => {
        console.log('Video1 started playing');
        // Create background
        createBackgroundWithTexture(videoTexture1);
      }).catch(error => {
        console.error('Failed to play initial video:', error);
        fallbackToImage();
      });
    }

    // Set common properties for video textures
    function setupVideoTexture(texture) {
      texture.wrapS = THREE.ClampToEdgeWrapping;
      texture.wrapT = THREE.ClampToEdgeWrapping;
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.center.set(0.5, 0.5);
      texture.repeat.set(1, 1);
      texture.encoding = THREE.sRGBEncoding;
    }

    function fallbackToImage() {
      // Fallback to static image
      console.log('Using static image as background');
      const loader = new THREE.TextureLoader();
      loader.load('storytelling/forest_background.jpg', function (texture) {
        createBackgroundWithTexture(texture);
      });
    }

    // Update background size based on window size
    function updateBackgroundSize(background) {
      const aspectRatio = window.innerWidth / window.innerHeight;
      let newWidth, newHeight;

      if (aspectRatio > 16 / 9) {
        // Wide screen device, prioritize width
        newWidth = 60 * aspectRatio / (16 / 9); // Reduce from 80 to 60
        newHeight = 60 * (9 / 16);
      } else {
        // Tall screen device, prioritize height
        newWidth = 60; // Reduce from 80 to 60
        newHeight = 60 / aspectRatio * (16 / 9);
      }

      background.geometry = new THREE.PlaneGeometry(newWidth, newHeight);
      console.log(`Screen adjustment: ${aspectRatio.toFixed(2)}, New background size: ${newWidth.toFixed(2)}x${newHeight.toFixed(2)}`);
    }

    // Create background using given texture
    function createBackgroundWithTexture(texture) {
      console.log('Creating background, using texture:', texture);

      // Calculate background size to make it smaller
      const aspectRatio = window.innerWidth / window.innerHeight;
      let bgWidth, bgHeight;

      if (aspectRatio > 16 / 9) {
        // Wide screen device, prioritize width
        bgWidth = 60 * aspectRatio / (16 / 9); // Reduce from 80 to 60
        bgHeight = 60 * (9 / 16);
      } else {
        // Tall screen device, prioritize height
        bgWidth = 60; // Reduce from 80 to 60
        bgHeight = 60 / aspectRatio * (16 / 9);
      }

      console.log(`Screen aspect ratio: ${aspectRatio.toFixed(2)}, Background size: ${bgWidth.toFixed(2)}x${bgHeight.toFixed(2)}`);

      const bgGeometry = new THREE.PlaneGeometry(bgWidth, bgHeight);
      const bgMaterial = new THREE.MeshBasicMaterial({
        map: texture,
        side: THREE.DoubleSide,
      });

      // Main background panel - adjust position and size
      videoBackground = new THREE.Mesh(bgGeometry, bgMaterial);
      videoBackground.position.set(0, 0, -18); // Slightly closer, adjusted from -20 to -18
      bookContainer.add(videoBackground);

      // Add particle effect
      addParticles(bookContainer);

      // Reduce fog to make video clearer
      scene.fog = new THREE.FogExp2(0xaaccff, 0.0005);

      // Adjust camera position for better background observation
      camera.position.z = 12;
      camTargetZ = 10;
    }

    // Modify particle effect to not block video
    function addParticles(parent) {
      const particlesGeometry = new THREE.BufferGeometry();
      const particleCount = 300; // Reduce particle count

      const positionArray = new Float32Array(particleCount * 3);
      const sizeArray = new Float32Array(particleCount);

      for (let i = 0; i < particleCount; i++) {
        // Randomly distributed around the field of view, not concentrated in the center
        const radius = 12 + Math.random() * 18; // Increase range of particle distribution
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI / 2; // Hemisphere distribution

        // Distributed around the area, not blocking the center of the video
        positionArray[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
        positionArray[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
        positionArray[i * 3 + 2] = -radius * Math.cos(phi) - 2; // Bias towards the back

        sizeArray[i] = 0.05 + Math.random() * 0.15; // Increase particle size
      }

      particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positionArray, 3));
      particlesGeometry.setAttribute('size', new THREE.BufferAttribute(sizeArray, 1));

      const particlesMaterial = new THREE.PointsMaterial({
        color: 0xffffff, // Use pure white, enhance brightness
        size: 0.15, // Increase size
        transparent: true,
        opacity: 0.7, // Increase opacity, improve visibility
        sizeAttenuation: true
      });

      const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
      parent.add(particleSystem);

      // Add slow rotation animation
      gsap.to(particleSystem.rotation, {
        y: Math.PI * 2,
        duration: 180, // Slower rotation
        repeat: -1,
        ease: "none"
      });
    }

    // Preload page1 video
    function preloadPage1Video() {
      // Create hidden video element
      page1VideoElement = document.createElement('video');
      page1VideoElement.id = 'page1Video';
      page1VideoElement.style.display = 'none';
      page1VideoElement.muted = true;
      page1VideoElement.playsInline = true;
      page1VideoElement.loop = true; // Loop playback
      page1VideoElement.crossOrigin = 'anonymous';
      page1VideoElement.preload = 'auto';

      // Add video source
      const source = document.createElement('source');
      source.src = 'storytelling/page1.mp4';
      source.type = 'video/mp4';
      page1VideoElement.appendChild(source);

      // Add to DOM
      document.body.appendChild(page1VideoElement);

      // Load video
      page1VideoElement.load();

      // Add load success event
      page1VideoElement.addEventListener('canplaythrough', function onCanPlay() {
        console.log('Page1 video loaded, ready to play');

        // Create video texture (but don't play yet)
        if (!page1VideoTexture) {
          page1VideoTexture = new THREE.VideoTexture(page1VideoElement);
          page1VideoTexture.minFilter = THREE.LinearFilter;
          page1VideoTexture.magFilter = THREE.LinearFilter;
          page1VideoTexture.format = THREE.RGBAFormat;
          page1VideoTexture.encoding = THREE.sRGBEncoding;
          page1VideoTexture.generateMipmaps = false;
        }

        // Remove event listener to avoid duplicate calls
        page1VideoElement.removeEventListener('canplaythrough', onCanPlay);
      });

      // Add error handling
      page1VideoElement.addEventListener('error', function (e) {
        console.error('Failed to load Page1 video:', e);
        // Load static image as fallback
        const loader = new THREE.TextureLoader();
        loader.load('storytelling/page1.jpg', function (texture) {
          page1VideoTexture = texture;
        });
      });

      console.log('Page1 video preloading started');
    }

    // Preload page2 video
    function preloadPage2Video() {
      // Create hidden video element
      page2VideoElement = document.createElement('video');
      page2VideoElement.id = 'page2Video';
      page2VideoElement.style.display = 'none';
      page2VideoElement.muted = true;
      page2VideoElement.playsInline = true;
      page2VideoElement.loop = true; // Allow video to loop playback
      page2VideoElement.crossOrigin = 'anonymous';
      page2VideoElement.preload = 'auto'; // Ensure preloading

      // Add video source
      const source = document.createElement('source');
      source.src = 'storytelling/page2.mp4';
      source.type = 'video/mp4';
      page2VideoElement.appendChild(source);

      // Add to DOM
      document.body.appendChild(page2VideoElement);

      // Load video
      page2VideoElement.load();

      // When video has loaded enough data
      page2VideoElement.addEventListener('canplaythrough', function onCanPlay() {
        console.log('Page2 video ready to play');

        // Create video texture (but don't play yet)
        if (!page2VideoTexture) {
          page2VideoTexture = new THREE.VideoTexture(page2VideoElement);
          page2VideoTexture.minFilter = THREE.LinearFilter;
          page2VideoTexture.magFilter = THREE.LinearFilter;
          page2VideoTexture.format = THREE.RGBAFormat;
          page2VideoTexture.encoding = THREE.sRGBEncoding;
          page2VideoTexture.generateMipmaps = false;
        }

        // Remove event listener to avoid duplicate calls
        page2VideoElement.removeEventListener('canplaythrough', onCanPlay);
      });

      // Add error handling
      page2VideoElement.addEventListener('error', function (e) {
        console.error('Failed to load Page2 video:', e);
        // Load static image as fallback
        const loader = new THREE.TextureLoader();
        loader.load('storytelling/page2.jpg', function (texture) {
          page2VideoTexture = texture;
        });
      });

      console.log('Page2 video preloading started');
    }

    // Preload page3 video
    function preloadPage3Video() {
      // Create hidden video element
      page3VideoElement = document.createElement('video');
      page3VideoElement.id = 'page3Video';
      page3VideoElement.style.display = 'none';
      page3VideoElement.muted = true;
      page3VideoElement.playsInline = true;
      page3VideoElement.loop = true; // Allow video to loop playback
      page3VideoElement.crossOrigin = 'anonymous';
      page3VideoElement.preload = 'auto'; // Ensure preloading

      // Add video source
      const source = document.createElement('source');
      source.src = 'storytelling/page3.mp4';
      source.type = 'video/mp4';
      page3VideoElement.appendChild(source);

      // Add to DOM
      document.body.appendChild(page3VideoElement);

      // Load video
      page3VideoElement.load();

      // When video has loaded enough data
      page3VideoElement.addEventListener('canplaythrough', function onCanPlay() {
        console.log('Page3 video ready to play');

        // Create video texture (but don't play yet)
        if (!page3VideoTexture) {
          page3VideoTexture = new THREE.VideoTexture(page3VideoElement);
          page3VideoTexture.minFilter = THREE.LinearFilter;
          page3VideoTexture.magFilter = THREE.LinearFilter;
          page3VideoTexture.format = THREE.RGBAFormat;
          page3VideoTexture.encoding = THREE.sRGBEncoding;
          page3VideoTexture.generateMipmaps = false;
        }

        // Remove event listener to avoid duplicate calls
        page3VideoElement.removeEventListener('canplaythrough', onCanPlay);
      });

      // Add error handling
      page3VideoElement.addEventListener('error', function (e) {
        console.error('Failed to load Page3 video:', e);
        // Load static image as fallback
        const loader = new THREE.TextureLoader();
        loader.load('storytelling/page3.jpg', function (texture) {
          page3VideoTexture = texture;
        });
      });

      console.log('Page3 video preloading started');
    }

    // Preload page4 video
    function preloadPage4Video() {
      // Create hidden video element
      page4VideoElement = document.createElement('video');
      page4VideoElement.id = 'page4Video';
      page4VideoElement.style.display = 'none';
      page4VideoElement.muted = true;
      page4VideoElement.playsInline = true;
      page4VideoElement.loop = true; // Allow video to loop playback
      page4VideoElement.crossOrigin = 'anonymous';
      page4VideoElement.preload = 'auto'; // Ensure preloading

      // Add video source
      const source = document.createElement('source');
      source.src = 'storytelling/page4.mp4';
      source.type = 'video/mp4';
      page4VideoElement.appendChild(source);

      // Add to DOM
      document.body.appendChild(page4VideoElement);

      // Load video
      page4VideoElement.load();

      // When video has loaded enough data
      page4VideoElement.addEventListener('canplaythrough', function onCanPlay() {
        console.log('Page4 video ready to play');

        // Create video texture (but don't play yet)
        if (!page4VideoTexture) {
          page4VideoTexture = new THREE.VideoTexture(page4VideoElement);
          page4VideoTexture.minFilter = THREE.LinearFilter;
          page4VideoTexture.magFilter = THREE.LinearFilter;
          page4VideoTexture.format = THREE.RGBAFormat;
          page4VideoTexture.encoding = THREE.sRGBEncoding;
          page4VideoTexture.generateMipmaps = false;
        }

        // Remove event listener to avoid duplicate calls
        page4VideoElement.removeEventListener('canplaythrough', onCanPlay);
      });

      // Add error handling
      page4VideoElement.addEventListener('error', function (e) {
        console.error('Failed to load Page4 video:', e);
        // Load static image as fallback
        const loader = new THREE.TextureLoader();
        loader.load('storytelling/page4.jpg', function (texture) {
          page4VideoTexture = texture;
        });
      });

      console.log('Page4 video preloading started');
    }

    // Preload page5 video
    function preloadPage5Video() {
      // Create hidden video element
      page5VideoElement = document.createElement('video');
      page5VideoElement.id = 'page5Video';
      page5VideoElement.style.display = 'none';
      page5VideoElement.muted = true;
      page5VideoElement.playsInline = true;
      page5VideoElement.loop = true; // Allow video to loop playback
      page5VideoElement.crossOrigin = 'anonymous';
      page5VideoElement.preload = 'auto'; // Ensure preloading

      // Add video source
      const source = document.createElement('source');
      source.src = 'storytelling/page5.mp4';
      source.type = 'video/mp4';
      page5VideoElement.appendChild(source);

      // Add to DOM
      document.body.appendChild(page5VideoElement);

      // Load video
      page5VideoElement.load();

      // When video has loaded enough data
      page5VideoElement.addEventListener('canplaythrough', function onCanPlay() {
        console.log('Page5 video ready to play');

        // Create video texture (but don't play yet)
        if (!page5VideoTexture) {
          page5VideoTexture = new THREE.VideoTexture(page5VideoElement);
          page5VideoTexture.minFilter = THREE.LinearFilter;
          page5VideoTexture.magFilter = THREE.LinearFilter;
          page5VideoTexture.format = THREE.RGBAFormat;
          page5VideoTexture.encoding = THREE.sRGBEncoding;
          page5VideoTexture.generateMipmaps = false;
        }

        // Remove event listener to avoid duplicate calls
        page5VideoElement.removeEventListener('canplaythrough', onCanPlay);
      });

      // Add error handling
      page5VideoElement.addEventListener('error', function (e) {
        console.error('Failed to load Page5 video:', e);
        // Load static image as fallback
        const loader = new THREE.TextureLoader();
        loader.load('storytelling/page5.jpg', function (texture) {
          page5VideoTexture = texture;
        });
      });

      console.log('Page5 video preloading started');
    }

    // Preload page6 video
    function preloadPage6Video() {
      // Create hidden video element
      page6VideoElement = document.createElement('video');
      page6VideoElement.id = 'page6Video';
      page6VideoElement.style.display = 'none';
      page6VideoElement.muted = true;
      page6VideoElement.playsInline = true;
      page6VideoElement.loop = true; // Allow video to loop playback
      page6VideoElement.crossOrigin = 'anonymous';
      page6VideoElement.preload = 'auto'; // Ensure preloading

      // Add video source
      const source = document.createElement('source');
      source.src = 'storytelling/page6.mp4';
      source.type = 'video/mp4';
      page6VideoElement.appendChild(source);

      // Add to DOM
      document.body.appendChild(page6VideoElement);

      // Load video
      page6VideoElement.load();

      // When video has loaded enough data
      page6VideoElement.addEventListener('canplaythrough', function onCanPlay() {
        console.log('Page6 video ready to play');

        // Create video texture (but don't play yet)
        if (!page6VideoTexture) {
          page6VideoTexture = new THREE.VideoTexture(page6VideoElement);
          page6VideoTexture.minFilter = THREE.LinearFilter;
          page6VideoTexture.magFilter = THREE.LinearFilter;
          page6VideoTexture.format = THREE.RGBAFormat;
          page6VideoTexture.encoding = THREE.sRGBEncoding;
          page6VideoTexture.generateMipmaps = false;
        }

        // Remove event listener to avoid duplicate calls
        page6VideoElement.removeEventListener('canplaythrough', onCanPlay);
      });

      // Add error handling
      page6VideoElement.addEventListener('error', function (e) {
        console.error('Failed to load Page6 video:', e);
        // Load static image as fallback
        const loader = new THREE.TextureLoader();
        loader.load('storytelling/page6.jpg', function (texture) {
          page6VideoTexture = texture;
        });
      });

      console.log('Page6 video preloading started');
    }

    // Preload cover video
    function preloadCoverVideo() {
      // Create hidden video element
      coverVideoElement = document.createElement('video');
      coverVideoElement.id = 'coverVideo';
      coverVideoElement.style.display = 'none';
      coverVideoElement.muted = true;
      coverVideoElement.playsInline = true;
      coverVideoElement.loop = true; // Loop playback
      coverVideoElement.crossOrigin = 'anonymous';
      coverVideoElement.preload = 'auto';

      // Add video source
      const source = document.createElement('source');
      source.src = 'storytelling/cover.mp4';
      source.type = 'video/mp4';
      coverVideoElement.appendChild(source);

      // Add to DOM
      document.body.appendChild(coverVideoElement);

      // Load video
      coverVideoElement.load();

      // Add load success event
      coverVideoElement.addEventListener('canplaythrough', function onCanPlay() {
        console.log('Cover video loaded, ready to play');

        // Create video texture
        if (!coverVideoTexture) {
          coverVideoTexture = new THREE.VideoTexture(coverVideoElement);
          coverVideoTexture.minFilter = THREE.LinearFilter;
          coverVideoTexture.magFilter = THREE.LinearFilter;
          coverVideoTexture.format = THREE.RGBAFormat;
          coverVideoTexture.encoding = THREE.sRGBEncoding;
          coverVideoTexture.generateMipmaps = false;

          // Create cover mesh
          const height = 5.5;
          const width = height * (2035 / 2044);

          const material = new THREE.MeshBasicMaterial({
            map: coverVideoTexture,
            side: THREE.DoubleSide,
            transparent: true,
          });

          const geometry = new THREE.PlaneGeometry(width, height);
          coverMesh = new THREE.Mesh(geometry, material);
          coverMesh.position.set(0, 0, 2); // Place cover in front center position
          coverMesh.scale.set(1.3, 1.3, 1.3); // Initial cover slightly enlarged
          coverMesh.userData = { type: 'cover' };
          bookContainer.add(coverMesh);

          // Save original position and scale of cover for reference by subsequent pages
          window.coverOriginalPosition = { x: 0, y: 0, z: 2 };
          window.coverOriginalScale = { x: 1.3, y: 1.3, z: 1.3 };

          // Save original transform of cover
          saveOriginalTransform(coverMesh);

          coverVideoElement.play().catch(e => {
            console.error('Unable to play cover video:', e);
          });

          console.log('Cover video mesh created');
        }

        // Remove event listener to avoid duplicate calls
        coverVideoElement.removeEventListener('canplaythrough', onCanPlay);
      });

      // Add error handling
      coverVideoElement.addEventListener('error', function (e) {
        console.error('Cover video loading failed:', e);
        // Load static image as fallback
        const loader = new THREE.TextureLoader();
        loader.load('storytelling/cover.jpg', function (texture) {
          coverVideoTexture = texture;

          // Create cover mesh
          const height = 5.5;
          const width = height * (2035 / 2044);

          const material = new THREE.MeshBasicMaterial({
            map: coverVideoTexture,
            side: THREE.DoubleSide,
            transparent: true,
          });

          const geometry = new THREE.PlaneGeometry(width, height);
          coverMesh = new THREE.Mesh(geometry, material);
          coverMesh.position.set(0, 0, 2); // Place cover in front center position
          coverMesh.scale.set(1.3, 1.3, 1.3); // Initial cover slightly enlarged
          coverMesh.userData = { type: 'cover' };
          bookContainer.add(coverMesh);

          // Save original position and scale of cover for reference by subsequent pages
          window.coverOriginalPosition = { x: 0, y: 0, z: 2 };
          window.coverOriginalScale = { x: 1.3, y: 1.3, z: 1.3 };

          // Save original transform of cover
          saveOriginalTransform(coverMesh);

          console.log('Cover image mesh created');
        });
      });

      console.log('Cover video preloading started');
    }

    // page1
    function slideCoverAnimation() {
      console.log("Starting cover slide animation");
      isAnimating = true;

      // Reset focus state
      focusedPage = null;

      // Get initial display position and size of cover
      const coverPos = window.coverOriginalPosition;
      const coverScale = window.coverOriginalScale;

      // If pageMesh already exists, remove it first
      if (pageMesh) {
        bookContainer.remove(pageMesh);
        pageMesh = null;
      }

      // Create page1 video plane
      const height = 5.5;
      const width = height * (2035 / 2044);

      const material = new THREE.MeshBasicMaterial({
        map: page1VideoTexture,
        side: THREE.DoubleSide,
        transparent: true,
        toneMapped: false
      });

      const geometry = new THREE.PlaneGeometry(width, height);
      pageMesh = new THREE.Mesh(geometry, material);

      // Initial position set to right side for right-to-left page turning
      pageMesh.position.set(7, 0, -1);
      pageMesh.scale.set(1, 1, 1);
      pageMesh.rotation.y = 0.2; // Initial slight rotation
      pageMesh.userData = { type: 'page1' };
      pageMesh.visible = true;
      bookContainer.add(pageMesh);

      // Start playing page1 video
      if (page1VideoElement) {
        page1VideoElement.currentTime = 0;
        page1VideoElement.play().catch(err => {
          console.error('Unable to play page1 video:', err);
        });
      }

      // Create a spine object, fixed on the left
      const spineGeometry = new THREE.BoxGeometry(0.2, height, 0.3);
      const spineMaterial = new THREE.MeshBasicMaterial({ color: 0x555555 });
      const spine = new THREE.Mesh(spineGeometry, spineMaterial);
      spine.position.set(-width / 2 - 0.1, 0, 0); // Fixed at left edge
      pageMesh.add(spine);

      // Cover leftward rotation animation (around spine)
      gsap.to(coverMesh.position, {
        x: -7, // Move to left position
        y: 0,
        z: -2, // Move backward
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Cover shrink leftward
      gsap.to(coverMesh.scale, {
        x: 0.9,
        y: 0.9,
        z: 0.9,
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Add cover rotation effect
      gsap.to(coverMesh.rotation, {
        y: -0.2, // Slight left rotation
        duration: 1.2,
        ease: "power2.inOut"
      });

      // First page right-to-left turning animation
      gsap.to(pageMesh.position, {
        x: coverPos.x, // Move to center position
        y: coverPos.y,
        z: coverPos.z,
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2 // Slight delay
      });

      // First page scales to original cover size
      gsap.to(pageMesh.scale, {
        x: coverScale.x,
        y: coverScale.y,
        z: coverScale.z,
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2
      });

      // First page rotates to face front
      gsap.to(pageMesh.rotation, {
        y: 0, // Rotate back to front
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2,
        onComplete: function () {
          storyShown = true;
          isAnimating = false;
          currentPage = 1;

          // Set each page to correct visibility
          if (coverMesh) coverMesh.visible = true;
          if (pageMesh) pageMesh.visible = true;
          if (page2Mesh) page2Mesh.visible = false;

          // Save original transform of first page
          saveOriginalTransform(pageMesh);

          // To maintain layer relationship, ensure page1 is on top
          bookContainer.remove(pageMesh);
          bookContainer.add(pageMesh);

          console.log("Cover slide animation complete, current page:", currentPage);
        }
      });

      // Simultaneously move camera slightly to better observe the entire scene
      gsap.to(camera.position, {
        x: 0,
        y: 2,
        z: 12,
        duration: 1.5,
        ease: "power1.inOut"
      });
    }

    // 
    function turnToPage2Animation() {
      if (isAnimating) return;

      isAnimating = true;
      currentPage = 2; // 

      // 
      focusedPage = null;

      // 
      const coverPos = window.coverOriginalPosition;
      const coverScale = window.coverOriginalScale;

      // page2Mesh
      if (page2Mesh) {
        bookContainer.remove(page2Mesh);
        page2Mesh = null;
      }

      // page2
      const height = 5.5;
      const width = height * (2035 / 2044);

      const material = new THREE.MeshBasicMaterial({
        map: page2VideoTexture,
        side: THREE.DoubleSide,
        transparent: true,
        toneMapped: false,
      });

      const geometry = new THREE.PlaneGeometry(width, height);
      page2Mesh = new THREE.Mesh(geometry, material);

      // 
      page2Mesh.position.set(7, 0, -1);
      page2Mesh.scale.set(1, 1, 1);
      page2Mesh.rotation.y = 0.2; // 
      page2Mesh.userData = { type: 'page2' };
      page2Mesh.visible = true;
      bookContainer.add(page2Mesh);

      // 
      const spineGeometry = new THREE.BoxGeometry(0.2, height, 0.3);
      const spineMaterial = new THREE.MeshBasicMaterial({ color: 0x555555 });
      const spine = new THREE.Mesh(spineGeometry, spineMaterial);
      spine.position.set(-width / 2 - 0.1, 0, 0); // 
      page2Mesh.add(spine);

      // page2
      if (page2VideoElement) {
        page2VideoElement.currentTime = 0;
        page2VideoElement.volume = 0;
        page2VideoElement.muted = true;
        page2VideoElement.play().catch(err => {
          console.error('Page2:', err);
        });
      }

      // page1
      gsap.to(pageMesh.position, {
        x: -7, // 
        y: 0,
        z: -2, // 
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Page1
      gsap.to(pageMesh.scale, {
        x: 0.9,
        y: 0.9,
        z: 0.9,
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Page1
      gsap.to(pageMesh.rotation, {
        y: -0.2, // 
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Page2
      gsap.to(page2Mesh.position, {
        x: coverPos.x, // 
        y: coverPos.y,
        z: coverPos.z,
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2 // 
      });

      // Page2
      gsap.to(page2Mesh.scale, {
        x: coverScale.x,
        y: coverScale.y,
        z: coverScale.z,
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2,
      });

      // Page2
      gsap.to(page2Mesh.rotation, {
        y: 0, // 
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2,
        onComplete: function () {
          // page2
          saveOriginalTransform(page2Mesh);

          // 
          bookContainer.remove(page2Mesh);
          bookContainer.add(page2Mesh);

          isAnimating = false;
          console.log('page2');
        }
      });

      // 
      gsap.to(camera.position, {
        x: 0,
        y: 2,
        z: 12,
        duration: 1.5,
        ease: "power1.inOut"
      });
    }

    // 
    function turnToPage3Animation() {
      if (isAnimating) return;

      isAnimating = true;
      currentPage = 3; // 

      // 
      focusedPage = null;

      // 
      const coverPos = window.coverOriginalPosition;
      const coverScale = window.coverOriginalScale;

      // page3Mesh
      if (page3Mesh) {
        bookContainer.remove(page3Mesh);
        page3Mesh = null;
      }

      // page3
      const height = 5.5;
      const width = height * (2035 / 2044);

      const material = new THREE.MeshBasicMaterial({
        map: page3VideoTexture,
        side: THREE.DoubleSide,
        transparent: true,
        toneMapped: false,
      });

      const geometry = new THREE.PlaneGeometry(width, height);
      page3Mesh = new THREE.Mesh(geometry, material);

      // 
      page3Mesh.position.set(7, 0, -1);
      page3Mesh.scale.set(1, 1, 1);
      page3Mesh.rotation.y = 0.2; // 
      page3Mesh.userData = { type: 'page3' };
      page3Mesh.visible = true;
      bookContainer.add(page3Mesh);

      // 
      const spineGeometry = new THREE.BoxGeometry(0.2, height, 0.3);
      const spineMaterial = new THREE.MeshBasicMaterial({ color: 0x555555 });
      const spine = new THREE.Mesh(spineGeometry, spineMaterial);
      spine.position.set(-width / 2 - 0.1, 0, 0); // 
      page3Mesh.add(spine);

      // page3
      if (page3VideoElement) {
        page3VideoElement.currentTime = 0;
        page3VideoElement.volume = 0;
        page3VideoElement.muted = true;
        page3VideoElement.play().catch(err => {
          console.error('Page3:', err);
        });
      }

      // page2
      gsap.to(page2Mesh.position, {
        x: -7, // 
        y: 0,
        z: -2, // 
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Page2
      gsap.to(page2Mesh.scale, {
        x: 0.9,
        y: 0.9,
        z: 0.9,
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Page2
      gsap.to(page2Mesh.rotation, {
        y: -0.2, // 
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Page3
      gsap.to(page3Mesh.position, {
        x: coverPos.x, // 
        y: coverPos.y,
        z: coverPos.z,
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2 // 
      });

      // Page3
      gsap.to(page3Mesh.scale, {
        x: coverScale.x,
        y: coverScale.y,
        z: coverScale.z,
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2,
      });

      // Page3
      gsap.to(page3Mesh.rotation, {
        y: 0, // 
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2,
        onComplete: function () {
          // page3
          saveOriginalTransform(page3Mesh);

          // 
          bookContainer.remove(page3Mesh);
          bookContainer.add(page3Mesh);

          isAnimating = false;
          console.log('page3');
        }
      });

      // 
      gsap.to(camera.position, {
        x: 0,
        y: 2,
        z: 12,
        duration: 1.5,
        ease: "power1.inOut"
      });
    }

    // 
    function turnToPage4Animation() {
      if (isAnimating) return;

      isAnimating = true;
      currentPage = 4; // 

      // 
      focusedPage = null;

      // 
      const coverPos = window.coverOriginalPosition;
      const coverScale = window.coverOriginalScale;

      // page4Mesh
      if (page4Mesh) {
        bookContainer.remove(page4Mesh);
        page4Mesh = null;
      }

      // page4
      const height = 5.5;
      const width = height * (2035 / 2044);

      const material = new THREE.MeshBasicMaterial({
        map: page4VideoTexture,
        side: THREE.DoubleSide,
        transparent: true,
        toneMapped: false,
      });

      const geometry = new THREE.PlaneGeometry(width, height);
      page4Mesh = new THREE.Mesh(geometry, material);

      // 
      page4Mesh.position.set(7, 0, -1);
      page4Mesh.scale.set(1, 1, 1);
      page4Mesh.rotation.y = 0.2; // 
      page4Mesh.userData = { type: 'page4' };
      page4Mesh.visible = true;
      bookContainer.add(page4Mesh);

      // 
      const spineGeometry = new THREE.BoxGeometry(0.2, height, 0.3);
      const spineMaterial = new THREE.MeshBasicMaterial({ color: 0x555555 });
      const spine = new THREE.Mesh(spineGeometry, spineMaterial);
      spine.position.set(-width / 2 - 0.1, 0, 0); // 
      page4Mesh.add(spine);

      // page4
      if (page4VideoElement) {
        page4VideoElement.currentTime = 0;
        page4VideoElement.volume = 0;
        page4VideoElement.muted = true;
        page4VideoElement.play().catch(err => {
          console.error('Page4:', err);
        });
      }

      // page3
      gsap.to(page3Mesh.position, {
        x: -7, // 
        y: 0,
        z: -2, // 
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Page3
      gsap.to(page3Mesh.scale, {
        x: 0.9,
        y: 0.9,
        z: 0.9,
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Page3
      gsap.to(page3Mesh.rotation, {
        y: -0.2, // 
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Page4
      gsap.to(page4Mesh.position, {
        x: coverPos.x, // 
        y: coverPos.y,
        z: coverPos.z,
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2 // 
      });

      // Page4
      gsap.to(page4Mesh.scale, {
        x: coverScale.x,
        y: coverScale.y,
        z: coverScale.z,
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2,
      });

      // Page4
      gsap.to(page4Mesh.rotation, {
        y: 0, // 
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2,
        onComplete: function () {
          // page4
          saveOriginalTransform(page4Mesh);

          // 
          bookContainer.remove(page4Mesh);
          bookContainer.add(page4Mesh);

          isAnimating = false;
          console.log('page4');
        }
      });

      // 
      gsap.to(camera.position, {
        x: 0,
        y: 2,
        z: 12,
        duration: 1.5,
        ease: "power1.inOut"
      });
    }

    // 
    function turnToPage5Animation() {
      if (isAnimating) return;

      isAnimating = true;
      currentPage = 5; // 

      // 
      focusedPage = null;

      // 
      const coverPos = window.coverOriginalPosition;
      const coverScale = window.coverOriginalScale;

      // page5Mesh
      if (page5Mesh) {
        bookContainer.remove(page5Mesh);
        page5Mesh = null;
      }

      // page5
      const height = 5.5;
      const width = height * (2035 / 2044);

      const material = new THREE.MeshBasicMaterial({
        map: page5VideoTexture,
        side: THREE.DoubleSide,
        transparent: true,
        toneMapped: false,
      });

      const geometry = new THREE.PlaneGeometry(width, height);
      page5Mesh = new THREE.Mesh(geometry, material);

      // 
      page5Mesh.position.set(7, 0, -1);
      page5Mesh.scale.set(1, 1, 1);
      page5Mesh.rotation.y = 0.2; // 
      page5Mesh.userData = { type: 'page5' };
      page5Mesh.visible = true;
      bookContainer.add(page5Mesh);

      // 
      const spineGeometry = new THREE.BoxGeometry(0.2, height, 0.3);
      const spineMaterial = new THREE.MeshBasicMaterial({ color: 0x555555 });
      const spine = new THREE.Mesh(spineGeometry, spineMaterial);
      spine.position.set(-width / 2 - 0.1, 0, 0); // 
      page5Mesh.add(spine);

      // page5
      if (page5VideoElement) {
        page5VideoElement.currentTime = 0;
        page5VideoElement.volume = 0;
        page5VideoElement.muted = true;
        page5VideoElement.play().catch(err => {
          console.error('Page5:', err);
        });
      }

      // page4
      gsap.to(page4Mesh.position, {
        x: -7, // 
        y: 0,
        z: -2, // 
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Page4
      gsap.to(page4Mesh.scale, {
        x: 0.9,
        y: 0.9,
        z: 0.9,
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Page4
      gsap.to(page4Mesh.rotation, {
        y: -0.2, // 
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Page5
      gsap.to(page5Mesh.position, {
        x: coverPos.x, // 
        y: coverPos.y,
        z: coverPos.z,
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2 // 
      });

      // Page5
      gsap.to(page5Mesh.scale, {
        x: coverScale.x,
        y: coverScale.y,
        z: coverScale.z,
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2,
      });

      // Page5
      gsap.to(page5Mesh.rotation, {
        y: 0, // 
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2,
        onComplete: function () {
          // page5
          saveOriginalTransform(page5Mesh);

          // 
          bookContainer.remove(page5Mesh);
          bookContainer.add(page5Mesh);

          isAnimating = false;
          console.log('page5');
        }
      });

      // 
      gsap.to(camera.position, {
        x: 0,
        y: 2,
        z: 12,
        duration: 1.5,
        ease: "power1.inOut"
      });
    }

    // 
    function turnToPage6Animation() {
      if (isAnimating) return;

      isAnimating = true;
      currentPage = 6; // 

      // 
      focusedPage = null;

      // 
      const coverPos = window.coverOriginalPosition;
      const coverScale = window.coverOriginalScale;

      // page6Mesh
      if (page6Mesh) {
        bookContainer.remove(page6Mesh);
        page6Mesh = null;
      }

      // page6
      const height = 5.5;
      const width = height * (2035 / 2044);

      const material = new THREE.MeshBasicMaterial({
        map: page6VideoTexture,
        side: THREE.DoubleSide,
        transparent: true,
        toneMapped: false,
      });

      const geometry = new THREE.PlaneGeometry(width, height);
      page6Mesh = new THREE.Mesh(geometry, material);

      // 
      page6Mesh.position.set(7, 0, -1);
      page6Mesh.scale.set(1, 1, 1);
      page6Mesh.rotation.y = 0.2; // 
      page6Mesh.userData = { type: 'page6' };
      page6Mesh.visible = true;
      bookContainer.add(page6Mesh);

      // 
      const spineGeometry = new THREE.BoxGeometry(0.2, height, 0.3);
      const spineMaterial = new THREE.MeshBasicMaterial({ color: 0x555555 });
      const spine = new THREE.Mesh(spineGeometry, spineMaterial);
      spine.position.set(-width / 2 - 0.1, 0, 0); // 
      page6Mesh.add(spine);

      // page6
      if (page6VideoElement) {
        page6VideoElement.currentTime = 0;
        page6VideoElement.volume = 0;
        page6VideoElement.muted = true;
        page6VideoElement.play().catch(err => {
          console.error('Page6:', err);
        });
      }

      // page5
      gsap.to(page5Mesh.position, {
        x: -7, // 
        y: 0,
        z: -2, // 
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Page5
      gsap.to(page5Mesh.scale, {
        x: 0.9,
        y: 0.9,
        z: 0.9,
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Page5
      gsap.to(page5Mesh.rotation, {
        y: -0.2, // 
        duration: 1.2,
        ease: "power2.inOut"
      });

      // Page6
      gsap.to(page6Mesh.position, {
        x: coverPos.x, // 
        y: coverPos.y,
        z: coverPos.z,
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2 // 
      });

      // Page6
      gsap.to(page6Mesh.scale, {
        x: coverScale.x,
        y: coverScale.y,
        z: coverScale.z,
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2,
      });

      // Page6
      gsap.to(page6Mesh.rotation, {
        y: 0, // 
        duration: 1.2,
        ease: "power2.inOut",
        delay: 0.2,
        onComplete: function () {
          // page6
          saveOriginalTransform(page6Mesh);

          // 
          bookContainer.remove(page6Mesh);
          bookContainer.add(page6Mesh);

          isAnimating = false;
          console.log('page6');
        }
      });

      // 
      gsap.to(camera.position, {
        x: 0,
        y: 2,
        z: 12,
        duration: 1.5,
        ease: "power1.inOut"
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      let delta = clock.getDelta();

      // 
      if (!isAnimating && camera.position.z > camTargetZ) {
        camera.position.z -= delta * 2;
      }

      // 
      if (!isAnimating) {
        camera.position.y += Math.sin(clock.getElapsedTime() * 0.5) * 0.001;
        camera.position.x += Math.sin(clock.getElapsedTime() * 0.3) * 0.0005;
      }

      // 
      if (activeVideoTexture && !activeVideoElement.paused) {
        activeVideoTexture.needsUpdate = true;
      }

      // 
      updateVideoMaterials();

      renderer.render(scene, camera);
    }

    // 
    function updateVideoMaterials() {
      // 
      if (coverMesh && coverVideoTexture && coverVideoElement && !coverVideoElement.paused) {
        coverVideoTexture.needsUpdate = true;
      }

      // page1
      if (pageMesh && page1VideoTexture && page1VideoElement && !page1VideoElement.paused) {
        page1VideoTexture.needsUpdate = true;
      }

      // page2
      if (page2Mesh && page2VideoTexture && page2VideoElement && !page2VideoElement.paused) {
        page2VideoTexture.needsUpdate = true;
      }

      // page3
      if (page3Mesh && page3VideoTexture && page3VideoElement && !page3VideoElement.paused) {
        page3VideoTexture.needsUpdate = true;
      }

      // page4
      if (page4Mesh && page4VideoTexture && page4VideoElement && !page4VideoElement.paused) {
        page4VideoTexture.needsUpdate = true;
      }

      // page5
      if (page5Mesh && page5VideoTexture && page5VideoElement && !page5VideoElement.paused) {
        page5VideoTexture.needsUpdate = true;
      }

      // page6
      if (page6Mesh && page6VideoTexture && page6VideoElement && !page6VideoElement.paused) {
        page6VideoTexture.needsUpdate = true;
      }
    }

    //  - 
    // clickedObject: 
    function handlePageFocus(clickedObject) {
      // 
      if (isAnimating) return;

      console.log(":", clickedObject.userData.type);

      // ()
      if (clickedObject === focusedPage) {
        resetAllPages();
        return;
      }

      // 
      if (clickedObject === coverMesh) {
        directResetToPage(0, coverMesh);
        return;
      } else if (clickedObject === pageMesh) {
        directResetToPage(1, pageMesh);
        return;
      } else if (clickedObject === page2Mesh) {
        directResetToPage(2, page2Mesh);
        return;
      } else if (clickedObject === page3Mesh) {
        directResetToPage(3, page3Mesh);
        return;
      } else if (clickedObject === page4Mesh) {
        directResetToPage(4, page4Mesh);
        return;
      } else if (clickedObject === page5Mesh) {
        directResetToPage(5, page5Mesh);
        return;
      } else if (clickedObject === page6Mesh) {
        directResetToPage(6, page6Mesh);
        return;
      }

      // 
      console.warn(":", clickedObject);
    }

    // 
    function resetToInitialCoverState() {
      console.log("");
      isAnimating = true;

      // 
      gsap.to(camera.position, {
        x: 0,
        y: 2,
        z: camTargetZ,
        duration: 1,
        ease: "power2.inOut"
      });

      // 
      currentPage = 0;
      console.log("(0)");

      // 
      if (coverMesh) coverMesh.visible = true;
      if (pageMesh) pageMesh.visible = false;
      if (page2Mesh) page2Mesh.visible = false;
      if (page3Mesh) page3Mesh.visible = false;
      if (page4Mesh) page4Mesh.visible = false;
      if (page5Mesh) page5Mesh.visible = false;
      if (page6Mesh) page6Mesh.visible = false;

      // 
      if (coverVideoElement) {
        coverVideoElement.currentTime = 0;
        coverVideoElement.play().catch(e => console.error(':', e));
      }

      // 
      if (coverMesh) {
        // 
        gsap.to(coverMesh.position, {
          x: 0,
          y: 0,
          z: 2,
          duration: 1,
          ease: "power2.inOut"
        });

        gsap.to(coverMesh.scale, {
          x: 1.3,
          y: 1.3,
          z: 1.3,
          duration: 1,
          ease: "power2.inOut"
        });

        gsap.to(coverMesh.rotation, {
          y: 0,
          duration: 1,
          ease: "power2.inOut",
          onComplete: function () {
            bookContainer.remove(coverMesh);
            bookContainer.add(coverMesh);

            isAnimating = false;
            focusedPage = null;
            console.log('');
          }
        });
      }
    }

    // 
    function changeFocus(newFocusPage) {
      // 
      const oldFocusPage = focusedPage;


      // 
      bookContainer.remove(newFocusPage);
      bookContainer.add(newFocusPage);

      // 0.9
      gsap.to(oldFocusPage.position, {
        x: -4, // 
        y: 0, // 
        z: -5, // 
        duration: 1,
        ease: "power2.out"
      });

      // 0.9
      gsap.to(oldFocusPage.scale, {
        x: 0.9,
        y: 0.9,
        z: 0.9,
        duration: 1,
        ease: "power2.out"
      });

      // 
      gsap.to(oldFocusPage.rotation, {
        y: -0.2, // 
        duration: 1,
        ease: "power2.out"
      });

      // 
      saveOriginalTransform(newFocusPage);
      focusedPage = newFocusPage;

      // 1.8
      gsap.to(newFocusPage.position, {
        x: 0,
        y: 2,
        z: 2, // 
        duration: 1,
        ease: "power2.out"
      });

      gsap.to(newFocusPage.scale, {
        x: 1.8,
        y: 1.8,
        z: 1.8,
        duration: 1,
        ease: "back.out(1.1)"
      });

      // 0
      gsap.to(newFocusPage.rotation, {
        y: 0,
        duration: 1,
        ease: "power2.out",
        onComplete: function () {
          isAnimating = false;
        }
      });
    }

    // 
    function resetAllPages() {
      if (!focusedPage) {
        console.log("");
        return;
      }

      // 
      if (isAnimating) {
        console.log("");
        return;
      }

      console.log("");
      isAnimating = true;

      // 
      const savedCurrentPage = currentPage;
      console.log(":", savedCurrentPage);

      // 
      focusedPage = null;

      // 
      let targetMesh = null;
      switch (savedCurrentPage) {
        case 0:
          targetMesh = coverMesh;
          break;
        case 1:
          targetMesh = pageMesh;
          break;
        case 2:
          targetMesh = page2Mesh;
          break;
        case 3:
          targetMesh = page3Mesh;
          break;
        case 4:
          targetMesh = page4Mesh;
          break;
        case 5:
          targetMesh = page5Mesh;
          break;
        case 6:
          targetMesh = page6Mesh;
          break;
      }

      // directResetToPage
      if (targetMesh) {
        directResetToPage(savedCurrentPage, targetMesh);
      } else {
        console.error("");
        isAnimating = false;
      }
    }

    // 
    function saveOriginalTransform(object) {
      const id = object.uuid;
      if (!originalPositions[id]) {
        originalPositions[id] = {
          x: object.position.x,
          y: object.position.y,
          z: object.position.z
        };
      }

      if (!originalScales[id]) {
        originalScales[id] = {
          x: object.scale.x,
          y: object.scale.y,
          z: object.scale.z
        };
      }

      // 
      if (!object.userData.originalRotation) {
        object.userData.originalRotation = {
          x: object.rotation.x,
          y: object.rotation.y,
          z: object.rotation.z
        };
      }
    }

    // 
    function getAllVisiblePages() {
      const pages = [];
      if (coverMesh && coverMesh.visible) pages.push(coverMesh);
      if (pageMesh && pageMesh.visible) pages.push(pageMesh);
      if (page2Mesh && page2Mesh.visible) pages.push(page2Mesh);
      if (page3Mesh && page3Mesh.visible) pages.push(page3Mesh);
      if (page4Mesh && page4Mesh.visible) pages.push(page4Mesh);
      if (page5Mesh && page5Mesh.visible) pages.push(page5Mesh);
      if (page6Mesh && page6Mesh.visible) pages.push(page6Mesh);
      return pages;
    }

    // 
    function logPagePositions() {
      console.log('---  ---');
      if (coverMesh) console.log(':', coverMesh.position, coverMesh.scale);
      if (pageMesh) console.log(':', pageMesh.position, pageMesh.scale);
      if (page2Mesh) console.log(':', page2Mesh.position, page2Mesh.scale);
      if (page3Mesh) console.log(':', page3Mesh.position, page3Mesh.scale);
      if (page4Mesh) console.log(':', page4Mesh.position, page4Mesh.scale);
      if (page5Mesh) console.log(':', page5Mesh.position, page5Mesh.scale);
      if (page6Mesh) console.log(':', page6Mesh.position, page6Mesh.scale);
      console.log(':', focusedPage ? focusedPage.userData.type || '' : '');
      console.log('------------------');
    }

    // 
    function focusPage(page) {
      // 
      focusedPage = page;
      saveOriginalTransform(page);

      // 
      const otherPages = getAllVisiblePages().filter(p => p !== page);
      otherPages.forEach(p => saveOriginalTransform(p));

      // 
      bookContainer.remove(page);
      bookContainer.add(page); // 

      // 
      gsap.to(page.position, {
        x: 0, // 
        y: 2, // 
        z: 2, // 
        duration: 1,
        ease: "power2.out"
      });

      // 1.8
      gsap.to(page.scale, {
        x: 1.8,
        y: 1.8,
        z: 1.8,
        duration: 1,
        ease: "back.out(1.1)"
      });

      // 0
      gsap.to(page.rotation, {
        y: 0,
        duration: 0.8,
        ease: "power2.out"
      });

      // 0.9
      otherPages.forEach((otherPage, index) => {
        // 
        const angle = (index / otherPages.length) * Math.PI * 0.6; // 
        const offsetX = -4 - Math.sin(angle) * 3; // 
        const offsetZ = -3 - Math.cos(angle) * 2; // 

        gsap.to(otherPage.position, {
          x: offsetX,
          y: 0, // 
          z: offsetZ, // 
          duration: 1,
          ease: "power2.out"
        });

        // 0.9
        gsap.to(otherPage.scale, {
          x: 0.9,
          y: 0.9,
          z: 0.9,
          duration: 1,
          ease: "power2.out"
        });

        // 
        gsap.to(otherPage.rotation, {
          y: -0.2, // 
          duration: 1,
          ease: "power2.out"
        });
      });

      // 
      gsap.to(camera.position, {
        x: 0,
        y: 2,
        z: 10, // 
        duration: 1,
        ease: "power2.inOut",
        onComplete: function () {
          isAnimating = false;
          logPagePositions();
        }
      });
    }

    // 
    function updatePagesVisibility() {
      console.log("", currentPage);
      // 
      if (currentPage === 0) { // 
        if (coverMesh) coverMesh.visible = true;
        if (pageMesh) pageMesh.visible = false;
        if (page2Mesh) page2Mesh.visible = false;
        if (page3Mesh) page3Mesh.visible = false;
        if (page4Mesh) page4Mesh.visible = false;
        if (page5Mesh) page5Mesh.visible = false;
        if (page6Mesh) page6Mesh.visible = false;
      } else if (currentPage === 1) { // 
        if (coverMesh) coverMesh.visible = true;
        if (pageMesh) pageMesh.visible = true;
        if (page2Mesh) page2Mesh.visible = false;
        if (page3Mesh) page3Mesh.visible = false;
        if (page4Mesh) page4Mesh.visible = false;
        if (page5Mesh) page5Mesh.visible = false;
        if (page6Mesh) page6Mesh.visible = false;
      } else if (currentPage === 2) { // 
        if (coverMesh) coverMesh.visible = true;
        if (pageMesh) pageMesh.visible = true;
        if (page2Mesh) page2Mesh.visible = true;
        if (page3Mesh) page3Mesh.visible = false;
        if (page4Mesh) page4Mesh.visible = false;
        if (page5Mesh) page5Mesh.visible = false;
        if (page6Mesh) page6Mesh.visible = false;
      } else if (currentPage === 3) { // 
        if (coverMesh) coverMesh.visible = true;
        if (pageMesh) pageMesh.visible = true;
        if (page2Mesh) page2Mesh.visible = true;
        if (page3Mesh) page3Mesh.visible = true;
        if (page4Mesh) page4Mesh.visible = false;
        if (page5Mesh) page5Mesh.visible = false;
        if (page6Mesh) page6Mesh.visible = false;
      } else if (currentPage === 4) { // 
        if (coverMesh) coverMesh.visible = true;
        if (pageMesh) pageMesh.visible = true;
        if (page2Mesh) page2Mesh.visible = true;
        if (page3Mesh) page3Mesh.visible = true;
        if (page4Mesh) page4Mesh.visible = true;
        if (page5Mesh) page5Mesh.visible = false;
        if (page6Mesh) page6Mesh.visible = false;
      } else if (currentPage === 5) { // 
        if (coverMesh) coverMesh.visible = true;
        if (pageMesh) pageMesh.visible = true;
        if (page2Mesh) page2Mesh.visible = true;
        if (page3Mesh) page3Mesh.visible = true;
        if (page4Mesh) page4Mesh.visible = true;
        if (page5Mesh) page5Mesh.visible = true;
        if (page6Mesh) page6Mesh.visible = false;
      } else if (currentPage === 6) { // 
        if (coverMesh) coverMesh.visible = true;
        if (pageMesh) pageMesh.visible = true;
        if (page2Mesh) page2Mesh.visible = true;
        if (page3Mesh) page3Mesh.visible = true;
        if (page4Mesh) page4Mesh.visible = true;
        if (page5Mesh) page5Mesh.visible = true;
        if (page6Mesh) page6Mesh.visible = true;
      }
    }

    // resetToInitialCoverState()
    function directRestoreCoverState() {
      console.log("");

      // 
      currentPage = 0;

      // 
      if (coverMesh) {
        coverMesh.visible = true;

        // 
        gsap.to(coverMesh.position, {
          x: 0,
          y: 0,
          z: 2,
          duration: 1,
          ease: "power2.inOut"
        });

        gsap.to(coverMesh.scale, {
          x: 1.3,
          y: 1.3,
          z: 1.3,
          duration: 1,
          ease: "power2.inOut"
        });

        gsap.to(coverMesh.rotation, {
          y: 0,
          duration: 1,
          ease: "power2.inOut"
        });

        // 
        bookContainer.remove(coverMesh);
        bookContainer.add(coverMesh);
      }

      // 
      if (pageMesh) pageMesh.visible = false;
      if (page2Mesh) page2Mesh.visible = false;
      if (page3Mesh) page3Mesh.visible = false;
      if (page4Mesh) page4Mesh.visible = false;
      if (page5Mesh) page5Mesh.visible = false;
      if (page6Mesh) page6Mesh.visible = false;

      // 
      if (coverVideoElement) {
        coverVideoElement.currentTime = 0;
        coverVideoElement.play().catch(e => console.error(':', e));
      }

      // 
      gsap.to(camera.position, {
        x: 0,
        y: 2,
        z: camTargetZ,
        duration: 1,
        ease: "power2.inOut"
      });
    }

    // 
    function directResetToPage(pageNum, targetMesh) {
      // 
      console.log("=====  =====");
      console.log(":", pageNum, ":", targetMesh ? targetMesh.userData.type : "");
      console.log(":", currentPage, ":", focusedPage ? focusedPage.userData.type : "");

      // 
      if (isAnimating) {
        console.log("");
        return;
      }

      // pageNum
      if (pageNum < 0 || pageNum > 6) {
        console.error(":", pageNum);
        return;
      }

      // targetMesh
      if (!targetMesh) {
        console.error("");
        return;
      }

      isAnimating = true;
      console.log(":", pageNum, ":", targetMesh.userData.type);

      //  - targetMeshpageNum
      if (targetMesh === coverMesh) {
        pageNum = 0;
      } else if (targetMesh === pageMesh) {
        pageNum = 1;
      } else if (targetMesh === page2Mesh) {
        pageNum = 2;
      } else if (targetMesh === page3Mesh) {
        pageNum = 3;
      } else if (targetMesh === page4Mesh) {
        pageNum = 4;
      } else if (targetMesh === page5Mesh) {
        pageNum = 5;
      } else if (targetMesh === page6Mesh) {
        pageNum = 6;
      }

      // 
      currentPage = pageNum;
      console.log(":", pageNum);

      // 
      if (focusedPage) {
        console.log(":", focusedPage.userData.type);
        focusedPage = null;
      }

      // 
      const coverPos = window.coverOriginalPosition || { x: 0, y: 0, z: 2 };
      const coverScale = window.coverOriginalScale || { x: 1.3, y: 1.3, z: 1.3 };
      console.log(":", coverPos, ":", coverScale);

      // 
      stopAllVideos();

      // 
      if (pageNum === 0) {
        console.log("");
        // 
        if (coverMesh) coverMesh.visible = true;
        if (pageMesh) pageMesh.visible = false;
        if (page2Mesh) page2Mesh.visible = false;
        if (page3Mesh) page3Mesh.visible = false;
        if (page4Mesh) page4Mesh.visible = false;
        if (page5Mesh) page5Mesh.visible = false;
        if (page6Mesh) page6Mesh.visible = false;

        if (coverMesh) {
          gsap.to(coverMesh.position, {
            x: 0,
            y: 0,
            z: 2,
            duration: 1,
            ease: "power2.inOut"
          });

          gsap.to(coverMesh.scale, {
            x: 1.3,
            y: 1.3,
            z: 1.3,
            duration: 1,
            ease: "power2.inOut"
          });

          gsap.to(coverMesh.rotation, {
            y: 0,
            duration: 1,
            ease: "power2.inOut"
          });
        }

        // 
        if (coverVideoElement) {
          coverVideoElement.currentTime = 0;
          coverVideoElement.play().catch(e => console.error(':', e));
        }

        // 
        gsap.to(camera.position, {
          x: 0,
          y: 2,
          z: 12,
          duration: 1,
          ease: "power2.inOut",
          onComplete: function () {
            isAnimating = false;
            console.log("");
            logPagePositions();
          }
        });

        return;
      }

      // 
      console.log(":", pageNum);

      //  - 
      console.log(":");
      if (coverMesh) {
        coverMesh.visible = true;
        console.log("- ");
      }

      if (pageMesh) {
        pageMesh.visible = pageNum >= 1;
        console.log(`- ${pageNum >= 1 ? '' : ''}`);
      }

      if (page2Mesh) {
        page2Mesh.visible = pageNum >= 2;
        console.log(`- ${pageNum >= 2 ? '' : ''}`);
      }

      if (page3Mesh) {
        page3Mesh.visible = pageNum >= 3;
        console.log(`- ${pageNum >= 3 ? '' : ''}`);
      }

      if (page4Mesh) {
        page4Mesh.visible = pageNum >= 4;
        console.log(`- ${pageNum >= 4 ? '' : ''}`);
      }

      if (page5Mesh) {
        page5Mesh.visible = pageNum >= 5;
        console.log(`- ${pageNum >= 5 ? '' : ''}`);
      }

      if (page6Mesh) {
        page6Mesh.visible = pageNum >= 6;
        console.log(`- ${pageNum >= 6 ? '' : ''}`);
      }

      // 
      let currentTargetMesh = targetMesh;

      // 
      switch (pageNum) {
        case 1: currentTargetMesh = pageMesh; break;
        case 2: currentTargetMesh = page2Mesh; break;
        case 3: currentTargetMesh = page3Mesh; break;
        case 4: currentTargetMesh = page4Mesh; break;
        case 5: currentTargetMesh = page5Mesh; break;
        case 6: currentTargetMesh = page6Mesh; break;
      }

      if (!currentTargetMesh) {
        console.error(":", pageNum);
        isAnimating = false;
        return;
      }

      // 
      const visiblePages = [];
      if (coverMesh && coverMesh.visible) visiblePages.push(coverMesh);
      if (pageMesh && pageMesh.visible) visiblePages.push(pageMesh);
      if (page2Mesh && page2Mesh.visible) visiblePages.push(page2Mesh);
      if (page3Mesh && page3Mesh.visible) visiblePages.push(page3Mesh);
      if (page4Mesh && page4Mesh.visible) visiblePages.push(page4Mesh);
      if (page5Mesh && page5Mesh.visible) visiblePages.push(page5Mesh);
      if (page6Mesh && page6Mesh.visible) visiblePages.push(page6Mesh);

      console.log(":", visiblePages.length);

      // 
      if (currentTargetMesh) {
        saveOriginalTransform(currentTargetMesh);
      }

      //  - 
      visiblePages.forEach(page => {
        if (page !== currentTargetMesh) {
          console.log(":", page.userData.type);
          gsap.to(page.position, {
            x: -7, // 
            y: 0,
            z: -2, // 
            duration: 1,
            ease: "power2.inOut"
          });

          gsap.to(page.scale, {
            x: 0.9,
            y: 0.9,
            z: 0.9,
            duration: 1,
            ease: "power2.inOut"
          });

          gsap.to(page.rotation, {
            y: -0.2, // 
            duration: 1,
            ease: "power2.inOut"
          });
        }
      });

      // 
      console.log(":", currentTargetMesh.userData.type);
      gsap.to(currentTargetMesh.position, {
        x: coverPos.x, // 
        y: coverPos.y,
        z: coverPos.z,
        duration: 1,
        ease: "power2.inOut"
      });

      gsap.to(currentTargetMesh.scale, {
        x: coverScale.x,
        y: coverScale.y,
        z: coverScale.z,
        duration: 1,
        ease: "power2.inOut"
      });

      gsap.to(currentTargetMesh.rotation, {
        y: 0, // 
        duration: 1,
        ease: "power2.inOut"
      });

      // 
      console.log(":", currentTargetMesh.userData.type);
      bookContainer.remove(currentTargetMesh);
      bookContainer.add(currentTargetMesh);

      // 
      console.log(":", pageNum);
      switch (pageNum) {
        case 1:
          if (page1VideoElement) {
            page1VideoElement.currentTime = 0;
            page1VideoElement.play().catch(e => console.error('page1:', e));
          }
          break;
        case 2:
          if (page2VideoElement) {
            page2VideoElement.currentTime = 0;
            page2VideoElement.play().catch(e => console.error('page2:', e));
          }
          break;
        case 3:
          if (page3VideoElement) {
            page3VideoElement.currentTime = 0;
            page3VideoElement.play().catch(e => console.error('page3:', e));
          }
          break;
        case 4:
          if (page4VideoElement) {
            page4VideoElement.currentTime = 0;
            page4VideoElement.play().catch(e => console.error('page4:', e));
          }
          break;
        case 5:
          if (page5VideoElement) {
            page5VideoElement.currentTime = 0;
            page5VideoElement.play().catch(e => console.error('page5:', e));
          }
          break;
        case 6:
          if (page6VideoElement) {
            page6VideoElement.currentTime = 0;
            page6VideoElement.play().catch(e => console.error('page6:', e));
          }
          break;
      }

      // 
      gsap.to(camera.position, {
        x: 0,
        y: 2,
        z: 12,
        duration: 1,
        ease: "power2.inOut",
        onComplete: function () {
          isAnimating = false;
          console.log(":", pageNum);
          logPagePositions();
          console.log("=====  =====");
        }
      });
    }

    //  - 
    function stopAllVideos() {
      // 
      if (coverVideoElement && !coverVideoElement.paused) coverVideoElement.pause();
      if (page1VideoElement && !page1VideoElement.paused) page1VideoElement.pause();
      if (page2VideoElement && !page2VideoElement.paused) page2VideoElement.pause();
      if (page3VideoElement && !page3VideoElement.paused) page3VideoElement.pause();
      if (page4VideoElement && !page4VideoElement.paused) page4VideoElement.pause();
      if (page5VideoElement && !page5VideoElement.paused) page5VideoElement.pause();
      if (page6VideoElement && !page6VideoElement.paused) page6VideoElement.pause();
    }
  </script>
</body>

</html>